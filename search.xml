<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[不错的句子]]></title>
      <url>/2017/06/24/aboutlove/</url>
      <content type="html"><![CDATA[<blockquote>
<p>看到的两段不错的关于感情的句子，收藏下</p>
</blockquote>
<h5 id="1-我们在不同的关系里进退、抽身或沉溺，享受温柔或甜蜜、也遭受等待和折磨。大多数人并没有强大到能够自主，大多数人只是默默接受命运的安排，遇见附赠的恋爱。"><a href="#1-我们在不同的关系里进退、抽身或沉溺，享受温柔或甜蜜、也遭受等待和折磨。大多数人并没有强大到能够自主，大多数人只是默默接受命运的安排，遇见附赠的恋爱。" class="headerlink" title="1.我们在不同的关系里进退、抽身或沉溺，享受温柔或甜蜜、也遭受等待和折磨。大多数人并没有强大到能够自主，大多数人只是默默接受命运的安排，遇见附赠的恋爱。"></a>1.我们在不同的关系里进退、抽身或沉溺，享受温柔或甜蜜、也遭受等待和折磨。大多数人并没有强大到能够自主，大多数人只是默默接受命运的安排，遇见附赠的恋爱。</h5><h5 id="2-恋爱和婚姻，意味着感情的孵化，而不是框定。正如英国作家毛姆在《月亮与六便士》里写道的，”感情有理智所根本无法理解的理由”。我们之所以会有”择一城终老，遇一人白首”的浪漫，之所以会有”终于在人群中遇见你”的感动，恰恰不是因为我们被限定在某个群体里、某个圈内，而是因为那个合适的人契合了你对于世界的认知，进而成为了你的全世界。"><a href="#2-恋爱和婚姻，意味着感情的孵化，而不是框定。正如英国作家毛姆在《月亮与六便士》里写道的，”感情有理智所根本无法理解的理由”。我们之所以会有”择一城终老，遇一人白首”的浪漫，之所以会有”终于在人群中遇见你”的感动，恰恰不是因为我们被限定在某个群体里、某个圈内，而是因为那个合适的人契合了你对于世界的认知，进而成为了你的全世界。" class="headerlink" title="2.恋爱和婚姻，意味着感情的孵化，而不是框定。正如英国作家毛姆在《月亮与六便士》里写道的，”感情有理智所根本无法理解的理由”。我们之所以会有”择一城终老，遇一人白首”的浪漫，之所以会有”终于在人群中遇见你”的感动，恰恰不是因为我们被限定在某个群体里、某个圈内，而是因为那个合适的人契合了你对于世界的认知，进而成为了你的全世界。"></a>2.恋爱和婚姻，意味着感情的孵化，而不是框定。正如英国作家毛姆在《月亮与六便士》里写道的，”感情有理智所根本无法理解的理由”。我们之所以会有”择一城终老，遇一人白首”的浪漫，之所以会有”终于在人群中遇见你”的感动，恰恰不是因为我们被限定在某个群体里、某个圈内，而是因为那个合适的人契合了你对于世界的认知，进而成为了你的全世界。</h5>]]></content>
      
        <categories>
            
            <category> 自说自话 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[一老人]]></title>
      <url>/2017/06/24/oldman/</url>
      <content type="html"><![CDATA[<h6 id="连续好几晚在田老师吃饭时遇到了那个皮肤黝黑、衣衫褴褛的老大爷了，今晚我刚坐下，准备吃饭，就看到他拿着一个袋子驮着背走了进来。田老师不是什么高档餐馆，但也算是北京地区知名连锁的快餐品牌了，这个脏兮兮的大爷一进来就吸引了我的目光，他的一切都仿佛与这里的环境不相称。就好像，他那样的人只配吃路边的大排档，还是极脏乱的那种。他进来后很不巧地坐在了我隔壁的座位上，我心里很不情愿，端着盘子想逃离他。可是四处瞅了一眼没有满意的位置后又乖乖回来了。大爷依然不动声色地坐着，仿佛只要坐一会他就真的可以缓解这一天的疲劳。我努力让自己不受到他的影响，认真吃饭。可是我显然已经受到了他的影响，忍不住去瞟他、观察他。他居然在数钱，钱不多，大概也就几十块，但每一张钞票都很干净，叠在一起也很整洁，与他的外表极不相称，就好像这些钱与这个餐馆才是一体的，而他只是旁观者。看着他认真细致的、一张一张数钱的样子我不出意料地心酸了。我忍不住多看看他，觉得多看他一眼我就能弥补自己之前的行为所带来的惭愧感。"><a href="#连续好几晚在田老师吃饭时遇到了那个皮肤黝黑、衣衫褴褛的老大爷了，今晚我刚坐下，准备吃饭，就看到他拿着一个袋子驮着背走了进来。田老师不是什么高档餐馆，但也算是北京地区知名连锁的快餐品牌了，这个脏兮兮的大爷一进来就吸引了我的目光，他的一切都仿佛与这里的环境不相称。就好像，他那样的人只配吃路边的大排档，还是极脏乱的那种。他进来后很不巧地坐在了我隔壁的座位上，我心里很不情愿，端着盘子想逃离他。可是四处瞅了一眼没有满意的位置后又乖乖回来了。大爷依然不动声色地坐着，仿佛只要坐一会他就真的可以缓解这一天的疲劳。我努力让自己不受到他的影响，认真吃饭。可是我显然已经受到了他的影响，忍不住去瞟他、观察他。他居然在数钱，钱不多，大概也就几十块，但每一张钞票都很干净，叠在一起也很整洁，与他的外表极不相称，就好像这些钱与这个餐馆才是一体的，而他只是旁观者。看着他认真细致的、一张一张数钱的样子我不出意料地心酸了。我忍不住多看看他，觉得多看他一眼我就能弥补自己之前的行为所带来的惭愧感。" class="headerlink" title="连续好几晚在田老师吃饭时遇到了那个皮肤黝黑、衣衫褴褛的老大爷了，今晚我刚坐下，准备吃饭，就看到他拿着一个袋子驮着背走了进来。田老师不是什么高档餐馆，但也算是北京地区知名连锁的快餐品牌了，这个脏兮兮的大爷一进来就吸引了我的目光，他的一切都仿佛与这里的环境不相称。就好像，他那样的人只配吃路边的大排档，还是极脏乱的那种。他进来后很不巧地坐在了我隔壁的座位上，我心里很不情愿，端着盘子想逃离他。可是四处瞅了一眼没有满意的位置后又乖乖回来了。大爷依然不动声色地坐着，仿佛只要坐一会他就真的可以缓解这一天的疲劳。我努力让自己不受到他的影响，认真吃饭。可是我显然已经受到了他的影响，忍不住去瞟他、观察他。他居然在数钱，钱不多，大概也就几十块，但每一张钞票都很干净，叠在一起也很整洁，与他的外表极不相称，就好像这些钱与这个餐馆才是一体的，而他只是旁观者。看着他认真细致的、一张一张数钱的样子我不出意料地心酸了。我忍不住多看看他，觉得多看他一眼我就能弥补自己之前的行为所带来的惭愧感。"></a>连续好几晚在田老师吃饭时遇到了那个皮肤黝黑、衣衫褴褛的老大爷了，今晚我刚坐下，准备吃饭，就看到他拿着一个袋子驮着背走了进来。田老师不是什么高档餐馆，但也算是北京地区知名连锁的快餐品牌了，这个脏兮兮的大爷一进来就吸引了我的目光，他的一切都仿佛与这里的环境不相称。就好像，他那样的人只配吃路边的大排档，还是极脏乱的那种。他进来后很不巧地坐在了我隔壁的座位上，我心里很不情愿，端着盘子想逃离他。可是四处瞅了一眼没有满意的位置后又乖乖回来了。大爷依然不动声色地坐着，仿佛只要坐一会他就真的可以缓解这一天的疲劳。我努力让自己不受到他的影响，认真吃饭。可是我显然已经受到了他的影响，忍不住去瞟他、观察他。他居然在数钱，钱不多，大概也就几十块，但每一张钞票都很干净，叠在一起也很整洁，与他的外表极不相称，就好像这些钱与这个餐馆才是一体的，而他只是旁观者。看着他认真细致的、一张一张数钱的样子我不出意料地心酸了。我忍不住多看看他，觉得多看他一眼我就能弥补自己之前的行为所带来的惭愧感。</h6><h6 id="他依然在数，我已经不知道那十几张一块、五块、十块的钞票他数了多少遍了。他越数，我越心酸，好像他在用这种行为报复我之前的无礼和浅薄。这时，餐馆的一个厨师出来了，调侃了一句“呦！大爷，今天挣了不少啊！”，大爷很害羞，用很低的声音嘟囔了一句后就去点菜了。可能受刚才那厨师的影响，点菜的声音依然很低沉，就像他不配点这些菜。负责点菜的服务员没听清又问了一下，旁边的扫地阿姨不耐烦了，嚷嚷着：“还是一样，三碗米饭、一碗汤-”他们的声音越大，大爷脸上越挂不住，好像点的太少是一种罪过。很快，饭菜都来了，大爷端着盘子颤颤巍巍地到我隔壁座位上坐下，我就那么看着，生怕他会摔倒。或许出去惭愧，又或许是好奇，我开口了“大爷，你为什么不回家去吃饭？家里不做吗？”。大爷没有觉得我太唐突，转过头，眼神里带着友好，好像还有一丝可怜，我觉得自己触到了他的痛处。他的声音很低，还带着口音，辗转几次问答我才知道他家里除了他自己就没其他人了，不知是没有结婚还是老伴已经去世，也没有儿女，而他自己则不能做饭，所以天天在外面吃。听到这，我连忙安慰他，我说我也天天在外面吃，而且跟你一样，吃了很多年了。大爷接着问我哪里人、做什么工作的、多大了。当我回答完最后一个问题时，大爷笑笑，但很明显，眼神比起刚才又落寞了许多，好像他在感叹他没我年轻，他已经没有机会重新选择了。我没说话，心里压抑得很。不想吃了，走之前我问大爷，“大爷，你有什么想吃的菜吗？我给你点份菜吧”，大爷拒绝了我的好意，这更让我的惭愧无法得到释怀。我友好的跟大爷告别，走出了餐馆。"><a href="#他依然在数，我已经不知道那十几张一块、五块、十块的钞票他数了多少遍了。他越数，我越心酸，好像他在用这种行为报复我之前的无礼和浅薄。这时，餐馆的一个厨师出来了，调侃了一句“呦！大爷，今天挣了不少啊！”，大爷很害羞，用很低的声音嘟囔了一句后就去点菜了。可能受刚才那厨师的影响，点菜的声音依然很低沉，就像他不配点这些菜。负责点菜的服务员没听清又问了一下，旁边的扫地阿姨不耐烦了，嚷嚷着：“还是一样，三碗米饭、一碗汤-”他们的声音越大，大爷脸上越挂不住，好像点的太少是一种罪过。很快，饭菜都来了，大爷端着盘子颤颤巍巍地到我隔壁座位上坐下，我就那么看着，生怕他会摔倒。或许出去惭愧，又或许是好奇，我开口了“大爷，你为什么不回家去吃饭？家里不做吗？”。大爷没有觉得我太唐突，转过头，眼神里带着友好，好像还有一丝可怜，我觉得自己触到了他的痛处。他的声音很低，还带着口音，辗转几次问答我才知道他家里除了他自己就没其他人了，不知是没有结婚还是老伴已经去世，也没有儿女，而他自己则不能做饭，所以天天在外面吃。听到这，我连忙安慰他，我说我也天天在外面吃，而且跟你一样，吃了很多年了。大爷接着问我哪里人、做什么工作的、多大了。当我回答完最后一个问题时，大爷笑笑，但很明显，眼神比起刚才又落寞了许多，好像他在感叹他没我年轻，他已经没有机会重新选择了。我没说话，心里压抑得很。不想吃了，走之前我问大爷，“大爷，你有什么想吃的菜吗？我给你点份菜吧”，大爷拒绝了我的好意，这更让我的惭愧无法得到释怀。我友好的跟大爷告别，走出了餐馆。" class="headerlink" title="他依然在数，我已经不知道那十几张一块、五块、十块的钞票他数了多少遍了。他越数，我越心酸，好像他在用这种行为报复我之前的无礼和浅薄。这时，餐馆的一个厨师出来了，调侃了一句“呦！大爷，今天挣了不少啊！”，大爷很害羞，用很低的声音嘟囔了一句后就去点菜了。可能受刚才那厨师的影响，点菜的声音依然很低沉，就像他不配点这些菜。负责点菜的服务员没听清又问了一下，旁边的扫地阿姨不耐烦了，嚷嚷着：“还是一样，三碗米饭、一碗汤!”他们的声音越大，大爷脸上越挂不住，好像点的太少是一种罪过。很快，饭菜都来了，大爷端着盘子颤颤巍巍地到我隔壁座位上坐下，我就那么看着，生怕他会摔倒。或许出去惭愧，又或许是好奇，我开口了“大爷，你为什么不回家去吃饭？家里不做吗？”。大爷没有觉得我太唐突，转过头，眼神里带着友好，好像还有一丝可怜，我觉得自己触到了他的痛处。他的声音很低，还带着口音，辗转几次问答我才知道他家里除了他自己就没其他人了，不知是没有结婚还是老伴已经去世，也没有儿女，而他自己则不能做饭，所以天天在外面吃。听到这，我连忙安慰他，我说我也天天在外面吃，而且跟你一样，吃了很多年了。大爷接着问我哪里人、做什么工作的、多大了。当我回答完最后一个问题时，大爷笑笑，但很明显，眼神比起刚才又落寞了许多，好像他在感叹他没我年轻，他已经没有机会重新选择了。我没说话，心里压抑得很。不想吃了，走之前我问大爷，“大爷，你有什么想吃的菜吗？我给你点份菜吧”，大爷拒绝了我的好意，这更让我的惭愧无法得到释怀。我友好的跟大爷告别，走出了餐馆。"></a>他依然在数，我已经不知道那十几张一块、五块、十块的钞票他数了多少遍了。他越数，我越心酸，好像他在用这种行为报复我之前的无礼和浅薄。这时，餐馆的一个厨师出来了，调侃了一句“呦！大爷，今天挣了不少啊！”，大爷很害羞，用很低的声音嘟囔了一句后就去点菜了。可能受刚才那厨师的影响，点菜的声音依然很低沉，就像他不配点这些菜。负责点菜的服务员没听清又问了一下，旁边的扫地阿姨不耐烦了，嚷嚷着：“还是一样，三碗米饭、一碗汤!”他们的声音越大，大爷脸上越挂不住，好像点的太少是一种罪过。很快，饭菜都来了，大爷端着盘子颤颤巍巍地到我隔壁座位上坐下，我就那么看着，生怕他会摔倒。或许出去惭愧，又或许是好奇，我开口了“大爷，你为什么不回家去吃饭？家里不做吗？”。大爷没有觉得我太唐突，转过头，眼神里带着友好，好像还有一丝可怜，我觉得自己触到了他的痛处。他的声音很低，还带着口音，辗转几次问答我才知道他家里除了他自己就没其他人了，不知是没有结婚还是老伴已经去世，也没有儿女，而他自己则不能做饭，所以天天在外面吃。听到这，我连忙安慰他，我说我也天天在外面吃，而且跟你一样，吃了很多年了。大爷接着问我哪里人、做什么工作的、多大了。当我回答完最后一个问题时，大爷笑笑，但很明显，眼神比起刚才又落寞了许多，好像他在感叹他没我年轻，他已经没有机会重新选择了。我没说话，心里压抑得很。不想吃了，走之前我问大爷，“大爷，你有什么想吃的菜吗？我给你点份菜吧”，大爷拒绝了我的好意，这更让我的惭愧无法得到释怀。我友好的跟大爷告别，走出了餐馆。</h6><h6 id="路上一直在想，为什么中国老话总说养儿防老？我以前总反感我的至亲长辈说这样的话，就好像养孩子只是为了他们自己一样，可是今晚我却不知道如何再反驳这句话，如果大爷有个儿女也不至于那么大年纪去收废品，每天只吃点米饭和一碗菠菜汤。我也不知道为什么这个社会上总有这些老人会触动我敏感的情绪，是因为骨子里我和他们一些无助，还是他们让我想起了无助又坚强的爷爷奶奶呢？还是我只是单纯的同情他们？我自己也不知道。我也纳闷，几千年来，人们一直在倡导高度文明的社会，古时有大同社会意愿，老有所依、幼有所样，今时有特色社会主义理想，各种社会保障制度齐全，为何还会有这样孤寡老人需要靠收废品为生？两千年来的理想至今实现不了。而我呢？则像个思想丑陋不堪的人一样，想远离这些脏乱无助的人们，我又如何配得上去同情别人呢？"><a href="#路上一直在想，为什么中国老话总说养儿防老？我以前总反感我的至亲长辈说这样的话，就好像养孩子只是为了他们自己一样，可是今晚我却不知道如何再反驳这句话，如果大爷有个儿女也不至于那么大年纪去收废品，每天只吃点米饭和一碗菠菜汤。我也不知道为什么这个社会上总有这些老人会触动我敏感的情绪，是因为骨子里我和他们一些无助，还是他们让我想起了无助又坚强的爷爷奶奶呢？还是我只是单纯的同情他们？我自己也不知道。我也纳闷，几千年来，人们一直在倡导高度文明的社会，古时有大同社会意愿，老有所依、幼有所样，今时有特色社会主义理想，各种社会保障制度齐全，为何还会有这样孤寡老人需要靠收废品为生？两千年来的理想至今实现不了。而我呢？则像个思想丑陋不堪的人一样，想远离这些脏乱无助的人们，我又如何配得上去同情别人呢？" class="headerlink" title="路上一直在想，为什么中国老话总说养儿防老？我以前总反感我的至亲长辈说这样的话，就好像养孩子只是为了他们自己一样，可是今晚我却不知道如何再反驳这句话，如果大爷有个儿女也不至于那么大年纪去收废品，每天只吃点米饭和一碗菠菜汤。我也不知道为什么这个社会上总有这些老人会触动我敏感的情绪，是因为骨子里我和他们一些无助，还是他们让我想起了无助又坚强的爷爷奶奶呢？还是我只是单纯的同情他们？我自己也不知道。我也纳闷，几千年来，人们一直在倡导高度文明的社会，古时有大同社会意愿，老有所依、幼有所样，今时有特色社会主义理想，各种社会保障制度齐全，为何还会有这样孤寡老人需要靠收废品为生？两千年来的理想至今实现不了。而我呢？则像个思想丑陋不堪的人一样，想远离这些脏乱无助的人们，我又如何配得上去同情别人呢？"></a>路上一直在想，为什么中国老话总说养儿防老？我以前总反感我的至亲长辈说这样的话，就好像养孩子只是为了他们自己一样，可是今晚我却不知道如何再反驳这句话，如果大爷有个儿女也不至于那么大年纪去收废品，每天只吃点米饭和一碗菠菜汤。我也不知道为什么这个社会上总有这些老人会触动我敏感的情绪，是因为骨子里我和他们一些无助，还是他们让我想起了无助又坚强的爷爷奶奶呢？还是我只是单纯的同情他们？我自己也不知道。我也纳闷，几千年来，人们一直在倡导高度文明的社会，古时有大同社会意愿，老有所依、幼有所样，今时有特色社会主义理想，各种社会保障制度齐全，为何还会有这样孤寡老人需要靠收废品为生？两千年来的理想至今实现不了。而我呢？则像个思想丑陋不堪的人一样，想远离这些脏乱无助的人们，我又如何配得上去同情别人呢？</h6>]]></content>
      
        <categories>
            
            <category> 自说自话 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[没有输过的木偶先生]]></title>
      <url>/2017/06/24/muou/</url>
      <content type="html"><![CDATA[<blockquote>
<p>(转）一位虚构的来访者，可以叫他木偶先生，最近被女友甩了。</p>
<p>他最后一次和女友谈话，是在常去的楼下的咖啡馆。他们坐了一个下午加晚上，大段大段的沉默和冷战。两个人都消耗得十分疲倦了。最后女友问：</p>
<p>  「那我们还要在一起么？」她是在很长的沉默后才问出这个问题。</p>
<p> 木偶先生抬起头，看着女友的眼睛。他知道这个问题很郑重，不管他做出什么回答，都必然会对他们两人的关系发生决定性的影响。他希望得到一点提示，例如从女友的眼神中感受到一点希冀之类，但是没有，后者仅仅只表现出了疲倦。</p>
<p>已经累到不行了，只是等待最后的一个宣判，什么宣判都无所谓一样。</p>
<p>  「……那你说怎么样？」木偶先生艰难地喝了一口咖啡。</p>
<p>  女友摇头：「每次都是我说，我现在想听你的态度。你，的，态，度。」</p>
<p> 「我啊……」木偶先生谨慎地措着词，「只要你愿意和我在一起的话，我当然也愿意继续……」他表达了自己的态度，心跳很剧烈，开始等待对方的回应。</p>
<p>  但女友看起来很失望，她低头，又沉默很久。而且好像哭了。</p>
<p>  「什么叫只要我愿意，只要我愿意，」她低着头小声说，「那我要是不愿意呢？」</p>
<p>   果然，就是不愿意。木偶先生觉得心像是被一点点浸到冰水里，整个人都凉了下去。她不愿意。木偶先生使劲咬住牙齿，努力地，保持住脸上的微笑。</p>
<p>   「那也无所谓，」他微笑着说，「你不愿意的话就算了吧。」</p>
<p>  他后仰着，靠着沙发背，两只手抄在风衣口袋里。挂着很淡的笑容。这样让他看起来总是有种遗世而独立的风度。他绝不能叹气，绝不能哭，当然更不可以抱怨或诅咒。没事的，他必须一点也不在乎。被拒绝的这种时刻，尤其不要失态。</p>
<p>  女友抬头盯着他，眼睛通红。啊，这有什么好哭的呢？明明是你自己要分。</p>
<p>   「就算了吗？啊？」女友又重复了一遍，「……所以你就算了吗？」</p>
<p>   木偶先生抄着手，尽力让自己的口气听起来超脱一些：「反正你不愿意的话，就算我想挽回也没有用了。」他潇洒地耸了耸肩，这是木偶先生的招牌动作。</p>
<p>   他结了账，保持平常的步态离开，虽然双腿像灌了铅。他努力让自己不要回头，不要让她看出来，否则自己就真的一败涂地，连离开也没法离开得很潇洒。</p>
<p>   于是后来朋友们就知道木偶先生分手了，而且是「和平分手」。</p>
<p>  「没有谁对不起谁，」木偶先生一边喝酒一边解释，「我们就是在一起太久了，遇到一些矛盾，我们认真地聊了一次，她觉得走不下去了，我说，那行吧……」</p>
<p>   「没想过挽回吗？」朋友们问，「就没有解决的办法？」</p>
<p>   木偶先生超然地笑：「要是刻意去求，求回来的那也不是真正的感情。」</p>
<p>   朋友们点头附和：「也是，强扭的瓜都没什么味道。」</p>
<p>   如果只是没有味道还好，木偶先生想，更有可能是完全失去一切。他想起自己的父母闹离婚时，母亲总是死按着他的头，母子俩一同跪在地上，苦苦哀求父亲不要离家。这样乞怜的结果，是让那段本该早死早超生的婚姻一次次苟延残喘。然而母亲或自己真正得到过好处么？不，只会让他们更畏惧父亲的脸色。无论何等过分的要求，无理的辱骂，甚至于荒唐无耻到极点的言行，母子俩也必须忍气吞声，默默承受。父亲就仿佛天经地义一般，在家里横行无忌，享受着像皇帝一样的威权。</p>
<p>   他一直躲在角落里满怀着恨意沉思，想为什么那么不公平，为什么父亲怎样都可以，为什么母亲和他就必须只能忍受欺负。后来他终于想清楚了答案：</p>
<p>  就因为母亲太在乎离婚被人耻笑。——所以一拿婚姻相胁，就输了。</p>
<p>  原来如此，越在乎一样东西，这样东西就越会成为你的软肋。随便遇到一个不在乎它的人，那你的地位就岌岌可危。只要被对方绑架了这样东西，你也就沦为了他的掌中之物，永世不得翻身。——只有这样东西对你来说变得不再重要，才能重新为你赢回主动权，你要学会懒洋洋地点根烟，告诉绑匪：「撕票吧，我无所谓。」</p>
<p>   于是木偶先生慢慢学会了这样的句式：「随便，你说了算，我无所谓。」</p>
<p>  他也学会了把双手抄进衣兜里，耸一耸肩。他挑眉毛的神情越来越潇洒。</p>
<p>   上学的时候他从来不主动向老师提问也不做习题，因为不希望被别人看出自己对成绩的在乎。「我看起来对学习很不用心，这样我会感觉更自由，考70分也不会丢脸，考90就更好。」而假如他暴露出自己的野心：我非常非常想考90！那他就会背负更多的钳制：他达不到90，就等于宣告了失败。他何必让自己冒这样的险呢？</p>
<p>   那么上班的时候也不要主动争取工作任务，更不要刻意讨好别人。</p>
<p>   谈恋爱也是如此。吃饭点菜是如此，看电影是如此，分手也是如此。</p>
<p>  你说了算，啊没关系，我无所谓，没事，随便，对我来说都一样，真的，不用不用。</p>
<p>   就连赶地铁的时候都是随便。木偶先生绝不会快跑几步，试图冲进还没有关上车门的地铁。遇到车门大开的时候，他仍旧步态从容，不紧不慢。——急吼吼地冲过去固然可能增加登车的概率，但谁能说得准车门关闭的时间？万一刚好吃了闭门羹怎么办？而假如从一开始就表现得根本不在乎，就能把从容完全地握在掌心。</p>
<p>  每个朋友都相信木偶先生是一个超脱而恬淡的哲学家，没有野心，没有追求，什么也无所谓。他就是与世无争的隐者，按照自己的节奏生活，活得很强大。</p>
<p>  拼命争取，总还是有可能争取不到，那就是输。</p>
<p>  夫唯不争，故天下莫能与之争。从一开始就不在乎，那无论怎样都是赢。</p>
<p>  从来都是赢的木偶先生，现在却有一个问题想不清楚。那就是为什么他赢了，但是他还感觉那么疼痛？现在他每天夜里失眠，早晨哭醒，打开衣柜就对着空掉的那块地方发呆，他说女友的离去就好像剜掉了他身上的肉。——他反复安慰自己说，这事想来想去，从一开头就已经注定结局，不可避免。自己不动声色，已经做到最好。但他也在怀疑，也许存在着某些机会，是悄无声息从自己身边溜掉了的。</p>
<p>  他在我的咨询室里掩面哭泣，重复朋友们的问题：「就没有解决的办法？」</p>
<p>  这是我唯一的一次见到他哭。他哭得很痛快，仿佛要把这些年所有错过的美好事物所带来的委屈都发泄出来。我没有回答他的问题，因为我知道他心里其实有答案。问题是那个答案永远只能藏在他心里。再过几分钟，他就会抽出纸巾擦干眼泪，整头发，手抄进口袋里，身子仰靠椅背，看看我，脸上挂起一副懒洋洋的笑。<br>  「哭完一通，感觉好多了。」他会这么告诉我。</p>
<p>「我知道你很难受，你心里很想她。」</p>
<p> 他不置可否地点了根烟，笑笑：「是难受啊，不过随便她吧，我无所谓。」然后轻松地耸一耸肩。<br>     ——得说，那副洒脱劲儿，确实会让人真以为无所谓。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 自说自话 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery与vue、react的区别]]></title>
      <url>/2017/06/18/jq_react_vue/</url>
      <content type="html"><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先，如jQuery；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先,如vue、react等。这是两者本质的区别。</p>
]]></content>
      
        <categories>
            
            <category> 自说自话 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery vue react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小数像素问题]]></title>
      <url>/2017/05/28/decimalpx/</url>
      <content type="html"><![CDATA[<blockquote>
<p>移动端经常会用rem做自适应页面，然后有时rem转换为px时会出现小数像素，<br>问题就在于不同的浏览器对小数像素的渲染不尽相同，有的是向下取整，有的是向上取整，这就导致页面中的盒子最后的大小有可能在不同浏览器中会出现1px的偏差。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue2.0与1.0比较]]></title>
      <url>/2017/04/25/vue2_vue1/</url>
      <content type="html"><![CDATA[<p>vue2.0:<br>    bower info vue</p>
<pre><code>http://vuejs.org/
</code></pre><p>到了2.0以后，有哪些变化?</p>
<ol>
<li>在每个组件模板，不在支持片段代码<br> 组件中模板:<pre><code>之前:
    &lt;template&gt;
        &lt;h3&gt;我是组件&lt;/h3&gt;&lt;strong&gt;我是加粗标签&lt;/strong&gt;
    &lt;/template&gt;
现在:  必须有根元素，包裹住所有的代码
    &lt;template id=&quot;aaa&quot;&gt;
            &lt;div&gt;
                &lt;h3&gt;我是组件&lt;/h3&gt;
                &lt;strong&gt;我是加粗标签&lt;/strong&gt;
            &lt;/div&gt;
    &lt;/template&gt;
</code></pre></li>
<li><p>关于组件定义<br> Vue.extend    这种方式，在2.0里面有，但是有一些改动，这种写法，即使能用，咱也不用——废弃</p>
<p> Vue.component(组件名称,{    在2.0继续能用</p>
<pre><code>data(){}
methods:{}
template:
</code></pre><p> });</p>
<p> 2.0推出一个组件，简洁定义方式：<br> var Home={</p>
<pre><code>template:&apos;&apos;        -&gt;   Vue.extend()
</code></pre><p> };</p>
</li>
<li>生命周期<br> 之前:<pre><code>init    
created
beforeCompile
compiled
ready        √    -&gt;     mounted
beforeDestroy    
destroyed
</code></pre> 现在:<pre><code>beforeCreate    组件实例刚刚被创建,属性都没有
created    实例已经创建完成，属性已经绑定
beforeMount    模板编译之前
mounted    模板编译之后，代替之前ready  *
beforeUpdate    组件更新之前
updated    组件更新完毕    *
beforeDestroy    组件销毁前
destroyed    组件销毁后
</code></pre></li>
<li><p>循环<br>1.0默认不可以添加重复数据 需要加上track-by = “$index”<br> 2.0里面默认就可以添加重复数据</p>
<p> arr.forEach(function(item,index){</p>
<p> });</p>
<p> 去掉了隐式一些变量</p>
<pre><code>$index    $key
</code></pre><p> 之前:</p>
<pre><code>v-for=&quot;(index,val) in array&quot;
</code></pre><p> 现在:</p>
<pre><code>v-for=&quot;(val,index) in array&quot;
</code></pre></li>
</ol>
<ol>
<li>track-by=”id”<br> 变成<pre><code>&lt;li v-for=&quot;(val,index) in list&quot; :key=&quot;index&quot;&gt;
</code></pre></li>
<li><p>自定义键盘指令<br> 之前：Vue.directive(‘on’).keyCodes.f1=17;    </p>
<p> 现在:  Vue.config.keyCodes.ctrl=17</p>
</li>
<li><p>过滤器<br> 之前:</p>
<pre><code>系统就自带很多过滤
{{msg | currency}}
{{msg | json}}
....
limitBy
filterBy
.....
</code></pre><p> 一些简单功能，自己通过js实现</p>
<p> 到了2.0， 内置过滤器，全部删除了</p>
</li>
</ol>
<pre><code>lodash    工具库    _.debounce(fn,200)


自定义过滤器——还有
    但是,自定义过滤器传参

    之前:    {{msg | toDou '12' '5'}}
    现在:     {{msg | toDou('12','5')}}
</code></pre><p>组件通信:<br>    vm.$emit()<br>    vm.$on();</p>
<pre><code>父组件和子组件:

子组件想要拿到父组件数据:
    通过  props

之前，子组件可以更改父组件信息，可以是同步  sync
现在，不允许直接给父级的数据，做赋值操作

问题，就想更改：
    a). 父组件每次传一个对象给子组件, 对象之间引用    √
    b). 只是不报错, mounted中转
</code></pre><p>可以单一事件管理组件通信:    vuex<br>    var Event=new Vue();</p>
<pre><code>Event.$emit(事件名称, 数据)

Event.$on(事件名称,function(data){
    //data
}.bind(this));
</code></pre><p>debounce    废弃<br>    -&gt;   lodash<br>        _.debounce(fn,时间)</p>
]]></content>
      
        <categories>
            
            <category> vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue2.0笔记]]></title>
      <url>/2017/04/25/vue2/</url>
      <content type="html"><![CDATA[<h4 id="1-v-show"><a href="#1-v-show" class="headerlink" title="1.v-show"></a>1.v-show</h4><p>如果一个元素在css里设置了display为none，再在html里添加v-show = true,那么不起作用。如果需求需要切换一个元素的隐藏和显示，不要在css里写display：none,直接用v-show = false/true就可以了。</p>
<h4 id="2-关于vue实例的挂载"><a href="#2-关于vue实例的挂载" class="headerlink" title="2.关于vue实例的挂载"></a>2.关于vue实例的挂载</h4><p>不要将Vue挂载到html或body- mount到普通元素。<br>  官方文档是这么解释的:</p>
<blockquote>
<p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到<br>html或者 body 上。</p>
</blockquote>
<h4 id="3-闪烁的问题"><a href="#3-闪烁的问题" class="headerlink" title="3. 闪烁的问题"></a>3. 闪烁的问题</h4><p>一般使用v-cloak指令解决闪烁的问题</p>
<blockquote>
<p>带有v-clock的的元素设置为display:none，隐藏掉，在等到vue解析到带有v-cloak的节点时候，会把attribute和class同时remove掉，直到vue编译结束。这样就可以实现防止节点的闪烁。</p>
</blockquote>
<pre><code>//css:
[v-cloak] {
    display: none;
    } 
//html:
&lt;div v-cloak&gt;
{{ message }}
&lt;/div&gt;
</code></pre><p>但是遇到一个问题，需要获取带有v-cloak节点中某按钮在页面中的位置，如果一开始就获取它的位置，此时这一节点的css没有设置，所以很可能导致获取到的按钮位置数据是错的，解决办法是在vue实例编译结束之后再来获取按钮的位置。</p>
<pre><code>mounted: function () {
    this.getHeaderBtnTop();
}，
 methods:{
    //获取头部按钮在页面中的高度
    getHeaderBtnTop:function() {
       this.headerBtnTop = $(&quot;#headerBtn&quot;).offset().top + $(&quot;#headerBtn&quot;).height();
        console.log(this.headerBtnTop);
    },
 }
</code></pre><h4 id="4-vue2-0的路由实例的三个方法"><a href="#4-vue2-0的路由实例的三个方法" class="headerlink" title="4.vue2.0的路由实例的三个方法"></a>4.vue2.0的路由实例的三个方法</h4><h5 id="4-1-router-push-location"><a href="#4-1-router-push-location" class="headerlink" title="4.1 router.push(location)"></a>4.1 router.push(location)</h5><p> 当调用router.push(location)时，浏览器的地址会变为”location”的地址，并且这个方法会向 history栈中 从后追加一个新的记录（这个记录地址是没有调用此方法之前的浏览器地址），所以，当用户点击浏览器后退按钮时，则回到之前的 URL。如果连续点击浏览器后退按钮，则按照history栈中的记录顺序倒着依次返回url。调用 router.push(…)等同于点击 标签 <router-link to="..."></router-link></p>
<pre><code>// 字符串
router.push(&apos;home&apos;)
// 对象
router.push({ path: &apos;home&apos; })
// 命名的路由
router.push({ name: &apos;user&apos;, params: { userId: 123 }})
// 带查询参数，变成 /register?plan=private
router.push({ path: &apos;register&apos;, query: { plan: &apos;private&apos; }})
</code></pre><p>router.push(location)这个方法类似于原生js中的widow.location.assign(location)和 window.history.pushState(…)</p>
<h5 id="4-2-router-replace-location"><a href="#4-2-router-replace-location" class="headerlink" title="4.2 router.replace(location)"></a>4.2 router.replace(location)</h5><p>跟 router.push(…) 很像，唯一的不同就是，它不会向 history 栈中添加新记录。<br>当调用router.replace(location)时，浏览器的地址会变为”location”的地址,对history栈不作操作。等同于点击 标签 <router-link to="..." replace=""></router-link>。网上有的文档说 “替换掉当前的 history 记录”,对这句话可以这么理解：</p>
<blockquote>
<p>如果是一般的 调用router.push(location)或者点击 标签 <router-link to="..."></router-link>，就会向 history栈中 从后追加一个新的记录，然而调用router.replace(location)这个则不会添加新记录，也就相当于把本应该添加的新记录替换成空了。我个人还是推荐理解成”对history栈不作操作,不会添加新记录”。</p>
</blockquote>
<p>router.replace(location)这个方法类似于原生js里widow.location.replace(location)和 window.history.replaceState(…)</p>
<h5 id="4-3-router-go-n"><a href="#4-3-router-go-n" class="headerlink" title="4.3 router.go(n)"></a>4.3 router.go(n)</h5><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。</p>
<pre><code>// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)
// 后退一步记录，等同于 history.back()
router.go(-1)
// 前进 3 步记录
router.go(3)
// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)
</code></pre><h4 id="5-引入组件或模块"><a href="#5-引入组件或模块" class="headerlink" title="5.引入组件或模块"></a>5.引入组件或模块</h4><p>如果是相对路径一定要写”../“或者”./“,不然会报错</p>
<h4 id="6-vue2-0官方推荐的axios不支持jsonp形式的跨域请求，只支持CORS形式的跨域，而如果想用CORS方案解决跨域问题需要在服务端设置-CORS-相关的-HTTP-头。"><a href="#6-vue2-0官方推荐的axios不支持jsonp形式的跨域请求，只支持CORS形式的跨域，而如果想用CORS方案解决跨域问题需要在服务端设置-CORS-相关的-HTTP-头。" class="headerlink" title="6.vue2.0官方推荐的axios不支持jsonp形式的跨域请求，只支持CORS形式的跨域，而如果想用CORS方案解决跨域问题需要在服务端设置 CORS 相关的 HTTP 头。"></a>6.vue2.0官方推荐的axios不支持jsonp形式的跨域请求，只支持CORS形式的跨域，而如果想用CORS方案解决跨域问题需要在服务端设置 CORS 相关的 HTTP 头。</h4>]]></content>
      
        <categories>
            
            <category> vue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于页面中的复制/剪切到剪切板功能]]></title>
      <url>/2017/03/23/copy/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近遇到一个需求，在页面上点击某按钮实现复制到剪切板功能，实现这一目的要比它本身看起来难得多。甚至可以说，就目前而言，没有一个通用的方法可以实现，我们能做的只有妥协。在FLASH 9 时代，有一个通杀所有浏览器的js复制内容到剪贴板的方案，也就是著名的Clipboard Copy解决方案 ，诸如zeroclipboard.js.利用一个clipboard.swf作为桥梁，复制内容到剪贴板。彼时浏览器Flash的安装率非常高，这几乎是一个完美的解决方案。然而，随着flash的落幕，这种方案现在已经被淘汰了。这里我们主要说下目前最有效的解决方案，clipboard.js.</p>
</blockquote>
<p> <a href="https://clipboardjs.com/" target="_blank" rel="external">clipboard.js </a>使用纯 JavaScript （无需 Flash）实现了复制浏览器内容到系统剪切板的功能，可以在浏览器和 Node 环境中使用。pc端支持的浏览器如下，Chrome 42+、Firefox 41+、IE 9+、Opera 29+。而移动端就没这么丰富了，iOS10以上支持，安卓手机上仅支持部分浏览器，下面是部分手机的统计情况：</p>
<table>
<thead>
<tr>
<th style="text-align:left">手机\浏览器</th>
<th style="text-align:left">自带浏览器</th>
<th style="text-align:right">微信浏览器</th>
<th style="text-align:center">UC浏览器</th>
<th style="text-align:center">QQ浏览器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">小米5</td>
<td style="text-align:left">支持</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">oppo r9</td>
<td style="text-align:left">不支持</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">华为荣耀6</td>
<td style="text-align:left">不支持</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:left">iphone6(iOS10.3)</td>
<td style="text-align:left">支持</td>
<td style="text-align:right">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:left">iphone5s(iOS9.2)</td>
<td style="text-align:left">不支持</td>
<td style="text-align:right">不支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<p>好在clipboard.js提供了Clipboard.isSupported()方法来检查浏览器的支持情况。代码如下：</p>
<pre><code>&lt;input id=&quot;foo&quot; value=&quot;123456&quot;&gt;
&lt;button class=&quot;btn&quot; id=&quot;btn&quot; data-clipboard- target=&quot;#foo&quot; data-clipboard-action=&quot;copy&quot;&gt;复制&lt;/button&gt;
&lt;script src=&quot;clipboard.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var btn = document.getElementById(&apos;btn&apos;);
    var clipboard = new Clipboard(btn);
    if(Clipboard.isSupported()) { //支持复制
        clipboard.on(&quot;success&quot;,function(){
            alert(&quot;复制成功&quot;);
        });
    }else {
        alert(&quot;您的浏览器不支持，请手动复制&quot;);//或在这里隐藏复制按钮
    }

&lt;/script&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[标准轮播图插件]]></title>
      <url>/2017/03/15/slider_plugin/</url>
      <content type="html"><![CDATA[<blockquote>
<p>pc端普通标准轮播图插件，带导航按钮，小圆点，自动轮播</p>
</blockquote>
<h5 id="1-html部分"><a href="#1-html部分" class="headerlink" title="1.html部分"></a>1.html部分</h5><pre><code>&lt;div class=&quot;slider-container&quot;&gt;

&lt;/div&gt;
</code></pre><h5 id="2-css部分"><a href="#2-css部分" class="headerlink" title="2.css部分"></a>2.css部分</h5><pre><code> html ,body,ul {
    margin: 0;
    padding: 0;
}
.slider-container ul li {
    list-style-type: none;

}
.clearfix:after {
    content:&quot;&quot;;
    height: 0;
    line-height: 0;
    visibility: hidden;
    display: block;
    clear: both;
}
.clearfix {
    zoom: 1;/*兼容ie浏览器*/
}
.slider-container {
    width: 500px;
    margin: 0 auto;
    overflow: hidden;
    position: relative;
}
.slider-body  {
    width: 5000px;
    position: relative;
}
.slider-body  li {

    float: left;
}
.slider-body li img {
    width: 500px;
    height: 300px;
}

.slider-container a {
    display: block;
}
.slider-container .button {
    width: 54px;
    height: 84px;
    position: absolute;
    top: 50%;
    margin-top: -42px;
}
.slider-container .prev {
    background: url(&quot;images/n_01.png&quot;) 0px 0px no-repeat;

}
.slider-container .next {
    background: url(&quot;images/n_01.png&quot;) -54px 0px no-repeat;
    right: 0;
}
.slider-points {
    position:absolute;
    bottom: 20px;
    left: 50%;
}
.slider-points li{
    width: 10px;
    height: 10px;
    border-radius: 5px;
    margin-left: 5px;
    background: #fff;
    cursor: pointer;
    opacity: .6;
    float: left;

}
.slider-points .current {
    background: red;
}
</code></pre><h5 id="3-js部分"><a href="#3-js部分" class="headerlink" title="3. js部分"></a>3. js部分</h5><pre><code>/*
 * pc 轮播图插件 基于jquery
 *  调用方式 $(&quot;.slider-container&quot;).jSlider(obj);
 *  传入一个对象obj 包含轮播图的图片地址数组imgUrlArr
 *  对象中可选参数 animateMilliSeconds  动画的过渡时间 毫秒计
 *  intervalMilliSeconds 定时器的间隔时间 毫秒计
 */
function jSlider(ele,opt) {
    this.$dom = $(ele);
    this.defaults = {
        animateMilliSeconds:300,
        intervalMilliSeconds:2000
    };
    this.options = $.extend({},this.defaults,opt);//注意这一步
    this.imgUrlArr = this.options.imgUrlArr;
    this.length = this.options.imgUrlArr.length;
    this.animateMilliSeconds = this.options.animateMilliSeconds;
    this.intervalMilliSeconds = this.options.intervalMilliSeconds;
    this.index = 0;
}

//轮播图初始化
jSlider.prototype.init = function() {
    this.create();
    this.$slideBox = $(&quot;.slider-body&quot;);
    this.liWidth = $(&quot;.slider-body  li&quot;).width();
    this.go();
    this.bindEvents();
};
//创建并添加元素
jSlider.prototype.create = function() {
    var slidercContainerStr = &apos;&apos;,
            sliderBodyStr = &apos;&apos;,
            sliderPointsStr = &apos;&apos;;
    for(var i = 0,l = this.length;i &lt; l;i ++) {
        sliderBodyStr += &apos;&lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;&apos;+this.imgUrlArr[i]+&apos;&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt;&apos;
        sliderPointsStr += &apos;&lt;li&gt;&lt;/li&gt;&apos;;
    }
    sliderBodyStr += &apos;&lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;&apos;+this.imgUrlArr[0]+&apos;&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt;&apos;
    slidercContainerStr += &apos;&lt;ul class=&quot;clearfix slider-body&quot;&gt;&apos;;
    slidercContainerStr +=  sliderBodyStr;
    slidercContainerStr += &apos;&lt;/ul&gt;&apos;;
    slidercContainerStr += &apos;&lt;a class=&quot;button prev &quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&apos;;
    slidercContainerStr += &apos;&lt;a class=&quot;button next&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&apos;;
    slidercContainerStr += &apos;&lt;ul class=&quot;slider-points clearfix&quot;&gt;&apos;;
    slidercContainerStr += sliderPointsStr;
    slidercContainerStr += &apos;&lt;/ul&gt;&apos;;
    this.$dom.html(slidercContainerStr);
    $(&quot;.slider-points li&quot;).eq(0).addClass(&quot;current&quot;);
    //小圆点盒子居中
    $(&quot;.slider-points&quot;).css(&quot;margin-left&quot;,$(&quot;.slider-points&quot;).width()/-2+&quot;px&quot;);

};
//基本动画
jSlider.prototype.animation = function() {
    this.$slideBox.stop().animate({
        &quot;left&quot;:-this.liWidth*this.index+&quot;px&quot;
    },this.animateMilliSeconds);
    $(&quot;.slider-points li&quot;).eq(this.index).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);
};
//下一个
jSlider.prototype.next = function() {
    this.index++;
    if(this.index == this.length) {
        $(&quot;.slider-points li&quot;).eq(0).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);

    }else if(this.index == this.length+1) {//最后一张图和第一张图是一样的
        this.index = 1;
        this.$slideBox.css( &quot;left&quot;,&quot;0&quot;);
    }
    this.animation();
};
//上一个
jSlider.prototype.prev = function() {
    this.index-- ;
    if(this.index == -1) {
        this.index = this.length-1;
        this.$slideBox.css( &quot;left&quot;,-this.liWidth*this.length+&quot;px&quot;);
    }
    this.animation();
};
//动画开始  开启定时器
jSlider.prototype.go = function() {
    var _this = this;
    this.sliderTimer = setInterval(function(){
        _this.next();
    },this.intervalMilliSeconds);
};
//动画停止
jSlider.prototype.stop = function() {
    clearInterval(this.sliderTimer);
};
//绑定事件
jSlider.prototype.bindEvents = function() {
    var _this = this;
    //点击左右按钮功能
    $(&quot;.slider-container &quot;).on(&quot;click&quot;,&quot;.next&quot;,function(){
        _this.next();

    });
    $(&quot;.slider-container &quot;).on(&quot;click&quot;,&quot;.prev&quot;,function(){
        _this.prev();
    });
    //鼠标移上定时器停止
    $(&quot;.slider-container&quot;).on(&quot;mouseover&quot;,function(){
        _this.stop();
    });
    $(&quot;.slider-container&quot;).on(&quot;mouseout&quot;,function(event){
        _this.go();
    });
    //点击slider下面的小圆点切换图片功能
    $(&quot;.slider-container &quot;).on(&quot;click&quot;,&quot;.slider-points li&quot;,function(){
        $(&quot;.slider-points  li&quot;).eq($(this).index()).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;);
        _this.$slideBox.stop().animate({left:-_this.liWidth*$(this).index()},_this.animateMilliSeconds);
        _this.index =$(this).index();
    });
};

//扩展jQuery的命名空间 （jQuery.fn = jQuery.prototype）
//这样每个jQuery实例都可以调用我们自己的插件
$.fn.jSlider = function (opt) {
     new jSlider(this,opt).init();
};
</code></pre><h5 id="4-调用方法"><a href="#4-调用方法" class="headerlink" title="4.调用方法"></a>4.调用方法</h5><pre><code>var obj = {
    imgUrlArr:[
        &quot;images/oushi05.jpg&quot;,
        &quot;images/oushi06.jpg&quot;,
        &quot;images/oushi09.jpg&quot;,
        &quot;images/10.jpg&quot;,
    ],
    animateMilliSeconds:400
};
$(&quot;.slider-container&quot;).jSlider(obj);
</code></pre>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简易loading插件]]></title>
      <url>/2017/03/13/loading_plugin/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简易的、带百分比的移动端loading插件</p>
</blockquote>
<h4 id="一-普通js-jquery-版本"><a href="#一-普通js-jquery-版本" class="headerlink" title="一.普通js(jquery)版本"></a>一.普通js(jquery)版本</h4><blockquote>
<p>将所有图片资源作为loading进度条的加载资源</p>
<h5 id="1-html部分"><a href="#1-html部分" class="headerlink" title="1.html部分"></a>1.html部分</h5><p>需要在所有有背景图片的盒子上手动添加一个为“bgimg”的类名，这样可以高效率地找到背景图片的链接，但也比较麻烦。可以用另一种方法，遍历页面中的所有元素获取背景图片链接，这样做的好处就是方便但性能较低。这里采用第一种方法。</p>
</blockquote>
<pre><code>&lt;div class=&quot;case&quot;&gt;
    &lt;div class=&quot; case1 bgimg&quot;&gt;&lt;/div&gt;
    &lt;img src=&quot;../images/bg.jpg&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;../images/lf.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
</code></pre><h5 id="2-css部分"><a href="#2-css部分" class="headerlink" title="2.css部分"></a>2.css部分</h5><pre><code>html,body {
       width: 100%;
       height: 100%;
   }
   .loading {
       width: 100%;
       height: 100%;
       background: #fff;
       position: absolute;
       top: 0;
       left: 0;
       z-index: 9999;
   }
   .loading-content {
       height: 10rem;
       width: 10rem;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-top:-5rem;
       margin-left: -5rem;
   }
   .spinner {
       width: 3rem;
       height: 3rem;
       margin: 1.75rem auto 1.25rem;
       position: relative;

   }

   .container1 &gt; div, .container2 &gt; div, .container3 &gt; div {
       width: .5rem;
       height: .5rem;
       background-color: #169af7;
       border-radius: 100%;
       position: absolute;
       -webkit-animation: bouncedelay 1.2s infinite ease-in-out;
       animation: bouncedelay 1.2s infinite ease-in-out;
       -webkit-animation-fill-mode: both;
       animation-fill-mode: both
   }

   .spinner .spinner-container {

       width: 2rem;
       height: 2rem;
       position: absolute;
       left: 50%;
       top: 30%;
       margin-left: -1rem;
   }

   .container2 {
       -webkit-transform: rotateZ(45deg);
       transform: rotateZ(45deg)
   }

   .container3 {
       -webkit-transform: rotateZ(90deg);
       transform: rotateZ(90deg)
   }

   .circle1 {
       top: 0;
       left: 0
   }

   .circle2 {
       top: 0;
       right: 0
   }

   .circle3 {
       right: 0;
       bottom: 0
   }

   .circle4 {
       left: 0;
       bottom: 0
   }

   .container2 .circle1 {
       -webkit-animation-delay: -1.1s;
       animation-delay: -1.1s
   }

   .container3 .circle1 {
       -webkit-animation-delay: -1.0s;
       animation-delay: -1.0s
   }

   .container1 .circle2 {
       -webkit-animation-delay: -0.9s;
       animation-delay: -0.9s
   }

   .container2 .circle2 {
       -webkit-animation-delay: -0.8s;
       animation-delay: -0.8s
   }

   .container3 .circle2 {
       -webkit-animation-delay: -0.7s;
       animation-delay: -0.7s
   }

   .container1 .circle3 {
       -webkit-animation-delay: -0.6s;
       animation-delay: -0.6s
   }

   .container2 .circle3 {
       -webkit-animation-delay: -0.5s;
       animation-delay: -0.5s
   }

   .container3 .circle3 {
       -webkit-animation-delay: -0.4s;
       animation-delay: -0.4s
   }

   .container1 .circle4 {
       -webkit-animation-delay: -0.3s;
       animation-delay: -0.3s
   }

   .container2 .circle4 {
       -webkit-animation-delay: -0.2s;
       animation-delay: -0.2s
   }

   .container3 .circle4 {
       -webkit-animation-delay: -0.1s;
       animation-delay: -0.1s
   }

   @-webkit-keyframes bouncedelay {
       0%, 80%, 100% {
           -webkit-transform: scale(0.0)
       }
       40% {
           -webkit-transform: scale(1.0)
       }
   }

   @keyframes bouncedelay {
       0%, 80%, 100% {
           transform: scale(0.0);
           -webkit-transform: scale(0.0)
       }
       40% {
           transform: scale(1.0);
           -webkit-transform: scale(1.0)
       }
   }

   .loading-percent {
       text-align: center;
       color: #000;
   }

     .case1 {
      width: 10rem;
      height: 20rem;
      background:url(&quot;../images/0.jpg&quot;) ;
  }
</code></pre><h5 id="3-js部分"><a href="#3-js部分" class="headerlink" title="3.js部分"></a>3.js部分</h5><pre><code> function jLoading(ele) {
    this.$dom = $(ele);
    this.imgUrlArr = this.getImgUrlArr();
    this.create();
    this.restOfProgress = 100;
    this.process = 0;
}
jLoading.prototype.create = function() {
    var htmlStr = &apos;&lt;div class=&quot;loading&quot;&gt;&apos;;
    htmlStr +=    &apos;&lt;div class=&quot;loading-content&quot;&gt;&apos;;
    htmlStr +=         &apos;&lt;div class=&quot;spinner&quot;&gt;&apos;;
    htmlStr +=             &apos;&lt;div class=&quot;spinner-container container1&quot;&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=             &apos;&lt;/div&gt;&apos;;
    htmlStr +=            &apos;&lt;div class=&quot;spinner-container container2&quot;&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=             &apos;&lt;/div&gt;&apos;;
    htmlStr +=             &apos;&lt;div class=&quot;spinner-container container3&quot;&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=                 &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
    htmlStr +=             &apos;&lt;/div&gt;&apos;;
    htmlStr +=         &apos;&lt;/div&gt;&apos;;
    htmlStr +=         &apos;&lt;div class=&quot;loading-percent&quot;&gt;&lt;span&gt;0&lt;/span&gt;%&lt;/div&gt;&apos;;
    htmlStr +=   &apos;&lt;/div&gt;&apos;;
    htmlStr += &apos;&lt;/div&gt;&apos;;
    this.$dom.before(htmlStr);
};
jLoading.prototype.getImgUrlArr = function() {
    var imgList = [],
            imgEle = this.$dom.find(&quot;img&quot;),
            bgImgEle = this.$dom.find(&quot;.bgimg&quot;),
            imgEleArr = [].slice.call(imgEle).concat([].slice.call(bgImgEle));
    for(var i= 0,l=imgEleArr.length;i&lt;l; i++){
        if($(imgEleArr[i]).attr(&quot;src&quot;)) {
            imgList.push($(imgEleArr[i]).attr(&quot;src&quot;).replace(&quot;http:&quot;,&quot;&quot;));
        }else if($(imgEleArr[i]).css(&quot;background&quot;)) {
            if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&quot;&apos;) != -1) {//安卓和windows chrome下返回 url(&quot;http://i0.letvimg.com/images/bg.jpg&quot;)
                var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;);
                a = a.substr(1,a.length-1);
                a=a.substr(0,a.length-1);
                imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));
            }else if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&apos;) != -1) {//  ios下返回url(http://i0.letvimg.com/images/bg.jpg)
                var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;);
                imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));
            }
        }
    }
    return imgList;
};
jLoading.prototype.loading = function() {
   var _this = this;
    var singleProcess = this.restOfProgress/this.imgUrlArr.length;//一张图片加载完成可以走的点
    for(var i = 0,l = this.imgUrlArr.length ; i&lt;l;i++) {
        var img = new Image();
        img.onload = function () {
            if ((_this.process + singleProcess) &lt; 100) {
                _this.process += singleProcess;
            } else {
                _this.process = 100;
            }
            _this.animate();
            if(_this.process == 100) {
               _this.loadingSuccess();
            }
        };
        img.src = this.imgUrlArr[i];
    }
};
jLoading.prototype.animate = function() {
    $(&quot;.loading-percent span&quot;).text(Math.ceil(this.process));
};
jLoading.prototype.loadingSuccess = function() {
    console.log(&quot;图片加载完成&quot;);
    $(&quot;.loading&quot;).hide();
};
$.fn.jLoading = function() {
    new jLoading(this).loading();
}
</code></pre><h5 id="4-调用方法"><a href="#4-调用方法" class="headerlink" title="4.调用方法"></a>4.调用方法</h5><blockquote>
<p>前面的jQuery对象是指所需要统计图片资源的大盒子，loading相关的html部分也会插入在这个大盒子之前。</p>
</blockquote>
<pre><code>$(&quot;.case&quot;).jLoading();
</code></pre><h4 id="二-createJS版本"><a href="#二-createJS版本" class="headerlink" title="二.createJS版本"></a>二.createJS版本</h4><blockquote>
<p>在createJS中的preloadJS库和soundJS库基础上封装的插件，将所有图片资源和音频资源作为loading进度条的加载资源。</p>
</blockquote>
<h5 id="1-html部分-1"><a href="#1-html部分-1" class="headerlink" title="1.html部分"></a>1.html部分</h5><blockquote>
<p>同样需要在所有有背景图片的盒子上手动添加一个为“bgimg”的类名，这样可以高效率地找到背景图片的链接，但也比较麻烦。可以用另一种方法，遍历页面中的所有元素获取背景图片链接，这样做的好处就是方便但性能较低。这里采用第一种方法。</p>
</blockquote>
<pre><code>&lt;div class=&quot;case&quot;&gt;
    &lt;!--音频开关--&gt;
    &lt;div class=&quot;sound-switch&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot; case1 bgimg&quot;&gt;&lt;/div&gt;
    &lt;img src=&quot;../images/bg.jpg&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;../images/lf.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
</code></pre><h5 id="2-css部分-1"><a href="#2-css部分-1" class="headerlink" title="2.css部分"></a>2.css部分</h5><blockquote>
<p>同上    </p>
<h5 id="3-js部分-1"><a href="#3-js部分-1" class="headerlink" title="3.js部分"></a>3.js部分</h5></blockquote>
<pre><code>&lt;script src=&quot;js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&apos;js/preloadjs-NEXT.combined.js&apos;&gt;&lt;/script&gt;
&lt;script src =&apos;js/soundjs-NEXT.combined.js&apos;&gt;&lt;/script&gt;
&lt;script&gt;
    function jLoading(ele) {
        this.$dom = $(ele);
        this.manifest = this.getImgUrlArr();
        this.create();
    }
    jLoading.prototype.create = function() {
        var htmlStr = &apos;&lt;div class=&quot;loading&quot;&gt;&apos;;
        htmlStr +=    &apos;&lt;div class=&quot;loading-content&quot;&gt;&apos;;
        htmlStr +=         &apos;&lt;div class=&quot;spinner&quot;&gt;&apos;;
        htmlStr +=             &apos;&lt;div class=&quot;spinner-container container1&quot;&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=             &apos;&lt;/div&gt;&apos;;
        htmlStr +=            &apos;&lt;div class=&quot;spinner-container container2&quot;&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=             &apos;&lt;/div&gt;&apos;;
        htmlStr +=             &apos;&lt;div class=&quot;spinner-container container3&quot;&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle1&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle2&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle3&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=                 &apos;&lt;div class=&quot;circle4&quot;&gt;&lt;/div&gt;&apos;;
        htmlStr +=             &apos;&lt;/div&gt;&apos;;
        htmlStr +=         &apos;&lt;/div&gt;&apos;;
        htmlStr +=         &apos;&lt;div class=&quot;loading-percent&quot;&gt;&lt;span&gt;0&lt;/span&gt;%&lt;/div&gt;&apos;;
        htmlStr +=   &apos;&lt;/div&gt;&apos;;
        htmlStr += &apos;&lt;/div&gt;&apos;;
        this.$dom.before(htmlStr);
    };
    jLoading.prototype.getImgUrlArr = function() {
        var imgList = [],
                imgEle = this.$dom.find(&quot;img&quot;),
                bgImgEle = this.$dom.find(&quot;.bgimg&quot;),
                imgEleArr = [].slice.call(imgEle).concat([].slice.call(bgImgEle));
        for(var i= 0,l=imgEleArr.length;i&lt;l; i++){
            if($(imgEleArr[i]).attr(&quot;src&quot;)) {
                imgList.push($(imgEleArr[i]).attr(&quot;src&quot;).replace(&quot;http:&quot;,&quot;&quot;));
            }else if($(imgEleArr[i]).css(&quot;background&quot;)) {
                if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&quot;&apos;) != -1) {//安卓和windows chrome下返回 url(&quot;http://i0.letvimg.com/images/bg.jpg&quot;)
                    var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;);
                    a = a.substr(1,a.length-1);
                    a=a.substr(0,a.length-1);
                    imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));
                }else if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&apos;) != -1) {//  ios下返回url(http://i0.letvimg.com/images/bg.jpg)
                    var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;);
                    imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));
                }
            }
        }
        return imgList;
    };
    jLoading.prototype.loading = function() {
        this.preload = new createjs.LoadQueue(true,&quot;&quot;);
        this.preload.installPlugin(createjs.Sound);
        this.preload.loadFile({id:&quot;sound&quot;, src:&quot;xingxing.mp3&quot;});
        this.preload.loadManifest(this.manifest);
        this.preload.on(&quot;progress&quot;,this.animate);
        this.preload.on(&quot;complete&quot;,this.loadingSuccess);
    };
    jLoading.prototype.animate = function() {
        //console.log(this);//这里的this不是指向jLoading 而是指向preload对象
        $(&quot;.loading-percent span&quot;).text(parseInt(this.progress*100));
    };
    jLoading.prototype.loadingSuccess = function() {
        //这里的this不是指向jLoading 而是指向preload对象
        console.log(&quot;图片和音乐加载完成&quot;);
        $(&quot;.loading&quot;).hide();
        mySound.soundManage();
    };
    $.fn.jLoading = function() {
        new jLoading(this).loading();

    }
    $(&quot;.case&quot;).jLoading();




    //音频管理
    var mySound = {
        soundManage: function () {
            this.soundPosition = 0;
            this.sound = createjs.Sound.play(&quot;sound&quot;);
            this.soundDom = $(&quot;.sound-switch&quot;);
            this.sound.on(&quot;complete&quot;, function () {
                this.sound.startTime = 0;
                this.sound.play();
            }.bind(this));
             this.soundDom.on(&quot;click&quot;, function () {
                this.soundControl();
            }.bind(this))
        },
        soundControl: function () {
            if( &quot;playFinished&quot; == this.sound.playState) {//音乐处于暂停状态
                this.sound.startTime = this.soundPosition;
                        this.sound.play();
                        this.soundDom.removeClass(&quot;off&quot;);
            }else if(&quot;playSucceeded&quot; == this.sound.playState){//音乐处于播放状态
                    this.soundPosition = this.sound.startTime + this.sound.position;
                    this.sound.stop();
                    this.soundDom.addClass(&quot;off&quot;);
            }
        }
    }
&lt;/script&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webstorm常用快捷键]]></title>
      <url>/2017/03/02/webstorm/</url>
      <content type="html"><![CDATA[<p>windows:</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:right">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">end</td>
<td style="text-align:right">光标移动到本行末尾</td>
</tr>
<tr>
<td style="text-align:left">ctrl+F</td>
<td style="text-align:right">文件内快速查找代码</td>
</tr>
<tr>
<td style="text-align:left">ctrl+R</td>
<td style="text-align:right">文件内代码替换</td>
</tr>
<tr>
<td style="text-align:left">ctrl+shift+R</td>
<td style="text-align:right">指定目录内代码批量替换</td>
</tr>
<tr>
<td style="text-align:left">ctrl+D</td>
<td style="text-align:right">复制当前行并自动粘贴到下一行</td>
</tr>
<tr>
<td style="text-align:left">ctrl+W</td>
<td style="text-align:right">选中单词</td>
</tr>
<tr>
<td style="text-align:left">ctrl+X</td>
<td style="text-align:right">删除当前行并复制此行到粘贴板</td>
</tr>
<tr>
<td style="text-align:left">shift+enter</td>
<td style="text-align:right">重新开始一行（无论光标在哪个位置）</td>
</tr>
<tr>
<td style="text-align:left">ctrl+]/[</td>
<td style="text-align:right">光标移动到代码块的前面或后面</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+/ 或 Ctrl+Shift+/</td>
<td style="text-align:right">注释（// 或者/<em>…</em>/ ）</td>
</tr>
<tr>
<td style="text-align:left">F2 或Shift+F2</td>
<td style="text-align:right">高亮错误或警告快速定位</td>
</tr>
<tr>
<td style="text-align:left">ctrl+←/→</td>
<td style="text-align:right">以单词作为边界跳光标位置</td>
</tr>
<tr>
<td style="text-align:left">ctrl+alt+L</td>
<td style="text-align:right">格式化代码</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Alt +T</td>
<td style="text-align:right">用 <em> 来围绕选中的代码行，（ </em> 包括 if 、 while 、 try catch 等）</td>
</tr>
<tr>
<td style="text-align:left">ctrl+shift+alt+N</td>
<td style="text-align:right">通过字符快速查找位置</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> webstorm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于原型链上的一些总结]]></title>
      <url>/2017/02/25/prototype/</url>
      <content type="html"><![CDATA[<blockquote>
<p>假设a是一个对象</p>
<ol>
<li>a.name = “jack” ；<br>一个点相当于在这个对象a上操作，如果有name属性则直接赋值， 如果没有name属性则先创建再赋值</li>
<li>a.info.name = ‘jack’；<br>两个点相当于先访问a对象上的info属性(这个info对象可以是a对象本身上的，也可以是a对象的原型对象上的)再在其上创建或修改name属性</li>
</ol>
</blockquote>
<h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><pre><code>var fun = function(){};
fun.prototype = {
    name:&apos;黑马&apos;,
    sum:100,
};
var a = new fun();
var b = new fun();
console.log( a.name);//黑马  直接访问a对象的name属性
console.log( b.name);//黑马  直接访问b对象的name属性    
</code></pre><h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2:"></a>case 2:</h4><pre><code>var fun = function(){};
fun.prototype = {
    name:&apos;黑马&apos;,
    sum:100,
};
var a = new fun();
var b = new fun();
a.name = &apos;黑马王子&apos;;//一个点相当于在这个对象上创建一个属性并赋值
b.name=&apos;白马王子&apos;;
console.log(a);
console.log(b);
console.log( a.name);//黑马王子
console.log( b.name);//白马王子    
</code></pre><h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3:"></a>case 3:</h4><pre><code>var fun = function(){
    this.info = {
        name: &quot;hh&quot;
    }
};
fun.prototype = {
    name:&apos;1&apos;,
    info : {
        name : &apos;peter&apos;,
        age : 25
    }
};
var a = new fun();
var b = new fun();
a.info.name = &apos;jack&apos;;
b.info.name = &apos;tom&apos;; //访问了b对象本身的info属性(对象)，并修改info上的name属性的属性值
console.log(a);
console.log(b);
console.log(a.info.name);//jack
console.log(b.info.name);//tom
</code></pre><h4 id="case-4"><a href="#case-4" class="headerlink" title="case 4:"></a>case 4:</h4><pre><code>var fun = function(){};
fun.prototype = {
    name:&apos;1&apos;,
    info : {
        name : &apos;peter&apos;,
        age : 25
    }
};
var a = new fun();
var b = new fun();
a.info.name = &apos;jack&apos;;
b.info.name = &apos;tom&apos;; //访问了b对象的原型对象上的info属性(对象)，并修改info上的name属性的属性值
console.log(a);
console.log(b);
console.log(a.info.name);//tom
console.log(b.info.name);//tom
</code></pre><h4 id="case-5"><a href="#case-5" class="headerlink" title="case 5:"></a>case 5:</h4><pre><code>var fun = function(){};
fun.prototype = {
    name:&apos;jj&apos;,
    info : {
        name : &apos;peter&apos;,
        age : 25
    }
};
var a = new fun();
var b = new fun();
a.info= {name:&quot;jack&quot;};
b.info = {name:&quot;tom&quot;}; //一个点相当于在这个b对象本身上创建一个info属性并赋值
console.log(a);
console.log(b);
console.log(a.info.name);//jack
console.log(b.info.name);//tom
</code></pre>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[定时器进阶]]></title>
      <url>/2017/02/13/setinterval/</url>
      <content type="html"><![CDATA[<h4 id="1-setTimeout-和setInterval-中可传入的参数除了通常的函数名和时间间隔外，HTML5规范还允许它们传入额外的参数，并在调用函数时把这些参数传递过去。（IE9及其以下版本IE浏览器不支持）"><a href="#1-setTimeout-和setInterval-中可传入的参数除了通常的函数名和时间间隔外，HTML5规范还允许它们传入额外的参数，并在调用函数时把这些参数传递过去。（IE9及其以下版本IE浏览器不支持）" class="headerlink" title="1. setTimeout()和setInterval()中可传入的参数除了通常的函数名和时间间隔外，HTML5规范还允许它们传入额外的参数，并在调用函数时把这些参数传递过去。（IE9及其以下版本IE浏览器不支持）"></a>1. setTimeout()和setInterval()中可传入的参数除了通常的函数名和时间间隔外，HTML5规范还允许它们传入额外的参数，并在调用函数时把这些参数传递过去。（IE9及其以下版本IE浏览器不支持）</h4><blockquote>
<p>这种方法比较容易理解，但是局限性太大导致也不常见<br>这里的字符串是一段JavaScript代码，其中的e表示的是变量，  而且经测试，这个变量要是个全局的，如果是在某函数里面如此调用setTimeout， 而此变量只是个函数内部变量的话，是会报变量不存在的。 </p>
</blockquote>
<pre><code>var e = 1;
var interval = setInterval(&quot;jj(e)&quot;,1000);
function jj(a) {
    e++;
    console.log(a);//输出1,2,3,4,5......
}
</code></pre><blockquote>
<p>setTimeout()和setInterval()中可传入的参数除了通常的函数名和时间间隔外，<br> HTML5规范还允许它们传入额外的参数，并在调用函数时把这些参数传递过去。（IE9及其以下版本IE浏览器不支持）<br>这种方式H5新增，但传参进定时器后跟预期不同，预期会输出1,2,3,4…<br> 实际输出1,1,1,1…<br> 因为目前在网上没找到相关资料，猜测是因为这种方式传参到定时器的执行函数里，<br> 定时器每次并不会重新获取该实参的值<br> 定时器的执行函数jj每次用的参数都是e的初始值</p>
</blockquote>
<pre><code>var e = 1;
var interval = setInterval(jj,1000,e);
function jj(a) {
    e ++;
    console.log(a);//输出1,1,1,1....

}
</code></pre><blockquote>
<pre><code>改造上述方法
在定时器的执行函数jj内部将实参和形参做个关联
用这种方法可以达到预期效果
</code></pre></blockquote>
<pre><code>var e = 1;
var interval = setInterval(jj,1000,e);
function jj(a) {
    e++;
    a = e;
    console.log(a);//输出2,3,4,5....

}
</code></pre>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git forking 工作流]]></title>
      <url>/2017/02/08/git_forking/</url>
      <content type="html"><![CDATA[<blockquote>
<p>  <em>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。</em></p>
</blockquote>
<p>Forking工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有仓库，另一个服务端公开仓库。</p>
<p><img src="https://segmentfault.com/img/remote/1460000006724865" alt=""><br>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。<br>开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。<br>这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。</p>
<p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。也让这个工作流成为开源项目的理想工作流。</p>
<h4 id="1-工作方式"><a href="#1-工作方式" class="headerlink" title="1.工作方式"></a>1.工作方式</h4><p>和其它的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上。<br>但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。</p>
<p>这个仓库拷贝作为他个人公开仓库 ——<br>其它开发者不允许push到这个仓库，但可以pull到修改（后面我们很快就会看这点很重要）。<br>在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。</p>
<p>要提交本地修改时，push提交到自己公开仓库中 —— 而不是正式仓库中。<br>然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。<br>对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。</p>
<p>为了集成功能到正式代码库，维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，<br>合并变更到自己本地的master分支，<br>然后pushmaster分支到服务器的正式仓库中。<br>到此，贡献的提交成为了项目的一部分，其它的开发者应该执行pull操作与正式仓库同步自己本地仓库。</p>
<h4 id="2-正式仓库"><a href="#2-正式仓库" class="headerlink" title="2 . 正式仓库"></a>2 . 正式仓库</h4><p>在Forking工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。<br>从技术上来看，各个开发者仓库和正式仓库在Git看来没有任何区别。<br>事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。</p>
<h4 id="3-Forking工作流的分支使用方式"><a href="#3-Forking工作流的分支使用方式" class="headerlink" title="3 .Forking工作流的分支使用方式"></a>3 .Forking工作流的分支使用方式</h4><p>所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。<br>各个开发者应该用分支隔离各个功能，就像在功能分支工作流和Gitflow工作流一样。<br>唯一的区别是这些分支被共享了。在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和Gitflow工作流中是直接被push到正式仓库中。</p>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h4><p>项目维护者初始化正式仓库<br>和任何使用Git项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。<br>通常这个仓库也会作为项目维护者的公开仓库。</p>
<p>公开仓库应该是裸仓库，不管是不是正式代码库。所以项目维护者会运行像下面的命令来搭建正式仓库：</p>
<pre><code>ssh user@host
git init --bare /path/to/repo.git
</code></pre><p>Bitbucket和Stash提供了一个方便的GUI客户端以完成上面命令行做的事。<br>这个搭建中央仓库的过程和前面提到的工作流完全一样。<br>如果有现存的代码库，维护者也要push到这个仓库中。</p>
<p>开发者fork正式仓库<br><img src="https://segmentfault.com/img/remote/1460000006724858" alt=""></p>
<p>其它所有的开发需要fork正式仓库。<br>可以用git clone命令用SSH协议连通到服务器，<br>拷贝仓库到服务器另一个位置 —— 是的，fork操作基本上就只是一个服务端的克隆。<br>Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。</p>
<p>这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。<br><img src="https://segmentfault.com/img/remote/1460000006724859" alt=""></p>
<p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。</p>
<p>在这个示例中，假定用Bitbucket托管了仓库。记住，如果这样的话各个开发者需要有各自的Bitbucket账号，使用下面命令克隆服务端自己的仓库：</p>
<pre><code>git clone https://user@bitbucket.org/us...
</code></pre><p>相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名 ——<br>一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名<br>（这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。</p>
<pre><code>git remote add upstream https://bitbucket.org/maintainer/repo
</code></pre><p>需要自己用上面的命令创建upstream别名。这样可以简单地保持本地仓库和正式仓库的同步更新。注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：</p>
<pre><code>git remote add upstream https://user@bitbucket.org/ma...
</code></pre><p>这时在克隆和pull正式仓库时，需要提供用户的密码。</p>
<p>开发者开发自己的功能.<br><img src="https://segmentfault.com/img/remote/1460000006724860" alt=""></p>
<p>在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、提交修改和新建分支：</p>
<pre><code>git checkout -b some-feature
Edit some code
git commit -a -m &quot;Add first draft of some feature&quot;
</code></pre><p>所有的修改都是私有的直到push到自己公开仓库中。如果正式项目已经往前走了，可以用git pull命令获得新的提交：</p>
<pre><code>git pull upstream master
</code></pre><p>由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。</p>
<p>开发者发布自己的功能</p>
<p><img src="https://segmentfault.com/img/remote/1460000006724861" alt=""></p>
<p>一旦开发者准备好了分享新功能，需要做二件事。<br>首先，通过push他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。<br>他的origin远程别名应该已经有了，所以要做的就是：</p>
<pre><code>git push origin feature-branch
</code></pre><p>这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。</p>
<p>第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。<br>Bitbucket和Stash提供了Pull Request按钮，弹出表单让你指定哪个分支要合并到正式仓库。<br>一般你会想集成你的功能分支到上游远程仓库的master分支中。</p>
<p>项目维护者集成开发者的功能<br><img src="https://segmentfault.com/img/remote/1460000006724862" alt=""></p>
<p>当项目维护者收到pull request，他要做的是决定是否集成它到正式代码库中。有二种方式来做：</p>
<p>直接在pull request中查看代码<br>pull代码到他自己的本地仓库，再手动合并<br>第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。<br>但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支，<br>合并到他本地的master分支，解决冲突：</p>
<pre><code>git fetch https://bitbucket.org/user/repo feature-branch
</code></pre><p>查看变更</p>
<pre><code>git checkout master
git merge FETCH_HEAD
</code></pre><p>变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其它的开发者都能访问到：</p>
<p>git push origin master注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。</p>
<p>开发者和正式仓库做同步<br><img src="https://segmentfault.com/img/remote/1460000006724864" alt=""><br>由于正式代码库往前走了，其它的开发需要和正式仓库做同步：</p>
<pre><code>git pull upstream master
</code></pre><p>如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。<br>但不要害怕，这个工作流实际上就是在功能分支工作流之上引入另一个抽象层。<br>不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。</p>
<p>示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但同样的方法可以把贡献集成到任一个仓库中。比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。</p>
<p>这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端 Git 工作流(le)]]></title>
      <url>/2017/02/08/git_qianduan/</url>
      <content type="html"><![CDATA[<h1 id="前端-Git-工作流-le"><a href="#前端-Git-工作流-le" class="headerlink" title="前端 Git 工作流(le)"></a>前端 Git 工作流(le)</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0 说明"></a>0 说明</h2><p>本工作流参考自<a href="http://wiki.letv.cn/pages/viewpage.action?pageId=53415515" target="_blank" rel="external">后端 git 工作流</a>，核心思想来自 Forking Workflow。</p>
<h3 id="0-1-目的"><a href="#0-1-目的" class="headerlink" title="0.1 目的"></a>0.1 目的</h3><p>我们的开发过程围绕着本工作流展开，同时我们希望的达到这样的目标：</p>
<ul>
<li>能够持续交付：我们没有固定的发布周期，我们希望主干版本的代码在任何时刻都是可部署的，更改一经通过审查就可以直接上线，这样我们才能很快地发布新的功能或者 Bug 修复，从而快速地获得用户对修改的反馈。</li>
<li>方便代码审查：我们很重视代码审查，所以这个流程对代码审查功能很友好。</li>
<li>使用代码沟通：代码是工程师沟通的最直接的渠道。我们希望每一次的更改提交都是独立的，专注并只专注一件事情，这样，我们就很容易地去了解这次更改背后要传达的信息。<h3 id="0-2-工具"><a href="#0-2-工具" class="headerlink" title="0.2 工具"></a>0.2 工具</h3></li>
</ul>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Git</td>
<td>2.9+</td>
<td></td>
</tr>
<tr>
<td>Gitlab</td>
<td></td>
<td><a href="http://legitlab.letv.cn" target="_blank" rel="external">legitlab.letv.cn</a></td>
</tr>
<tr>
<td>WebStorm/IDEA</td>
<td>2016.2+</td>
<td>图形化 Git 工具</td>
</tr>
</tbody>
</table>
<h3 id="0-3-角色"><a href="#0-3-角色" class="headerlink" title="0.3 角色"></a>0.3 角色</h3><table>
<thead>
<tr>
<th>权限</th>
<th>Developer(开发者)</th>
<th>Master(管理员) &amp; Owner(所有者)</th>
</tr>
</thead>
<tbody>
<tr>
<td>pull Project 代码</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>创建 merge request</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>创建 branch</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>push 代码到非保护分支</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>merge 和 push 代码到保护分支</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>为 Project 分配 Master 和 Developer 权限</td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Project 的角色可以从团队角色中继承而来，也可以由团队 Master（或 Owner ）单独提升开发者在某 Project 内的角色。</p>
<h2 id="1-仓库"><a href="#1-仓库" class="headerlink" title="1 仓库"></a>1 仓库</h2><h3 id="1-1-Group"><a href="#1-1-Group" class="headerlink" title="1.1 Group"></a>1.1 Group</h3><p>Group 是 Project 主仓库的集合，地址: <a href="http://legitlab.letv.cn/groups/levp-membership-fe" target="_blank" rel="external">🚩levp-membership-fe</a></p>
<h3 id="1-2-Project-主仓库"><a href="#1-2-Project-主仓库" class="headerlink" title="1.2 Project 主仓库"></a>1.2 Project 主仓库</h3><ul>
<li>Project 主仓库是以工程为单位来划分的。</li>
<li>Project 主仓库由团队 Master（或 Owner ）创建和维护。</li>
</ul>
<h2 id="2-分支"><a href="#2-分支" class="headerlink" title="2 分支"></a>2 分支</h2><p>Project 主仓库中仅含有1个 master 分支、1个 dev 分支和若干个 hotfix 分支，其中 master 分支和 dev 分支为保护分支。</p>
<h3 id="2-1-master-分支"><a href="#2-1-master-分支" class="headerlink" title="2.1 master 分支"></a>2.1 master 分支</h3><ul>
<li>master 分支由团队 Master（或 Owner ）创建和维护。</li>
<li>master 分支上的代码版本须于生产环境保持一致，每个 commit 必须对应版本 Tag。</li>
<li>master 分支关联至生产环境 CI 系统。</li>
</ul>
<h3 id="2-2-dev-分支"><a href="#2-2-dev-分支" class="headerlink" title="2.2 dev 分支"></a>2.2 dev 分支</h3><ul>
<li>dev 分支由团队 Master（或 Owner ）创建和维护。</li>
<li>dev 分支关联至测试环境 CI 系统。</li>
</ul>
<h3 id="2-3-hotfix-分支"><a href="#2-3-hotfix-分支" class="headerlink" title="2.3 hotfix 分支"></a>2.3 hotfix 分支</h3><ul>
<li>hotfix 分支的名称由 “hotfix” + “-“ + “自定义名称” 组成。</li>
<li>hotfix 分支由团队 Developer 或 Master（或 Owner ）创建和维护。</li>
<li>hotfix 分支在被合并回 master 后要及时删除。</li>
<li>hotfix 分支遵循谁创建谁维护谁删除的原则。</li>
</ul>
<h2 id="3-Fork-开发流程"><a href="#3-Fork-开发流程" class="headerlink" title="3 Fork 开发流程"></a>3 Fork 开发流程</h2><p>Fork 开发流程适用于正常的开发过程。</p>
<h3 id="3-1-Fork"><a href="#3-1-Fork" class="headerlink" title="3.1 Fork"></a>3.1 Fork</h3><p>Developer 从主仓库 Fork 主仓库的 dev 分支至私有仓库，然后在自己的私有仓库进行新功能的开发或 Bug 的修复。</p>
<h3 id="3-2-Merge-Request"><a href="#3-2-Merge-Request" class="headerlink" title="3.2 Merge Request"></a>3.2 Merge Request</h3><ul>
<li>开发完成后，需要在 Gitlab 创建 Merge Request 申请合并私有仓库的某分支到 Project 主仓库的 dev 分支。</li>
<li>有些时候，开发者在 Fork 代码后，创建 Merge Request 前，Project 主仓库可能已经接受了其他的 Merge Request，因此在合并前，开发者需要 pull Project 主仓库 dev 分支，到私有仓库需要合并的分支进行预合并。</li>
<li>发起 Merge Request 时要有详尽的说明描述本次合并请求的目的。</li>
<li>Merge Request 须指定给一名 Master（或 Owner ）做 Code Review 和 Merge，指定后须在自己的私有仓库给此 Master（或 Owner ）开放至少为 Developer 的角色权限。</li>
</ul>
<h3 id="3-3-Code-Review-amp-Merge"><a href="#3-3-Code-Review-amp-Merge" class="headerlink" title="3.3 Code Review &amp; Merge"></a>3.3 Code Review &amp; Merge</h3><p>Master（或 Owner ）按照研发规范对 Merge Request 进行代码审查，审查通过后合并至 dev 分支，审查不通过的需要驳回 Merge Request 并注明理由。</p>
<h3 id="3-4-Release"><a href="#3-4-Release" class="headerlink" title="3.4 Release"></a>3.4 Release</h3><p>当新的版本需要对外发布时， Master（或 Owner ）需要将 dev 分支合并入 master 分支并用 Tag 标明版本。</p>
<h2 id="4-Hotfix-开发流程"><a href="#4-Hotfix-开发流程" class="headerlink" title="4 Hotfix 开发流程"></a>4 Hotfix 开发流程</h2><p>Hotfix 开发流程适用于需要紧急修复线上 Bug 的情景，并作为 Fork 开发流程的补充。</p>
<h3 id="4-1-New-Branch"><a href="#4-1-New-Branch" class="headerlink" title="4.1 New Branch"></a>4.1 New Branch</h3><ul>
<li>当生产环境代码有急需修复的 Bug 时，从 master 分支新建 hotfix Branch。</li>
<li>开发者在 hotfix 分支完成 Bug 的修复。</li>
</ul>
<h3 id="4-2-Merge-Request"><a href="#4-2-Merge-Request" class="headerlink" title="4.2 Merge Request"></a>4.2 Merge Request</h3><p>修复完成后开发者发起 Merge Request 申请合并 hotfix 分支到 master 分支。</p>
<h3 id="4-3-Code-Review-amp-Merge-amp-Release"><a href="#4-3-Code-Review-amp-Merge-amp-Release" class="headerlink" title="4.3 Code Review &amp; Merge &amp; Release"></a>4.3 Code Review &amp; Merge &amp; Release</h3><ul>
<li>Master（或 Owner ）按照研发规范对 Merge Request 进行代码审查，审查通过后合并至 master 分支，分支并用 Tag 标明版本，审查不通过的需要驳回 Merge Request 并注明理由。</li>
<li>Master（或 Owner ）完成 master 的合并后，需要同时将 master 分支合并至 dev 分支，以保证修复 dev 分支上对应的 Bug。</li>
</ul>
<h3 id="4-4-删除分支"><a href="#4-4-删除分支" class="headerlink" title="4.4 删除分支"></a>4.4 删除分支</h3><p>当 hotfix 分支的合并被接受并完成发布后，创建者需要及时删除该分支。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[audio音频在移动端无法自动播放的问题]]></title>
      <url>/2016/12/12/audio/</url>
      <content type="html"><![CDATA[<p>audio音频设置了自动播放，但是在ios的微信和safari下还是无法自动播放，无论是用h5的audio的标签还是用createjs里的soundjs库都无法解决。处理办法一般是 设置自动播放属性，同时也监听触摸事件，因为是手机，所以人们会情不自禁的触摸屏幕，从而播放音乐，造成是自动播放的假象，提高了用户体验。</p>
<p>```<br>document.addEventListener(‘touchstart’, function(){<br>   audio.play();<br>}, false);</p>
<p>为了节省用户的流量，安卓跟ios都默认不允许开发者进行自动播放，除非用户进行页面操作，比较常用的方法，是在用户进行操作的时候，使用touch事件，控制音乐进行播放。如果在页面在微信中发布的话，可以用以下的方法尝试以下：</p>
<pre><code>&lt;audio style=&quot;display:none; height: 0&quot; id=&quot;bg-music&quot; preload=&quot;auto&quot; src=&quot;../static/videos/bg-music.mp3&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt;


document.addEventListener(&apos;DOMContentLoaded&apos;, function(){           function audioAutoPlay() {       
 var audio = document.getElementById(&apos;bg-music&apos;);           
 audio.play();        document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () {                audio.play();        
 }, false);   
  }    
 audioAutoPlay();
 });
</code></pre><p>监听DOMContentLoaded和load事件，实测在iPhone6s(ios10)、iPhone 6plus(ios8)中能顺利自动播放，没有测试全部iPhone的机型，估计iPhone是没问题的，安卓估计还是有部分不行，但是大部分机型能播放。我是讲上面两种方法结合起来，用户触摸的时候让音乐播放，监听微信的也播放，这是我能找到的比较完美的解决方案了，如果有更好的解决方案，欢迎提供交流。</p>
]]></content>
      
        <categories>
            
            <category> jquery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用jquery获取背景图片的路径的兼容问题]]></title>
      <url>/2016/11/05/jq_bgimage/</url>
      <content type="html"><![CDATA[<blockquote>
<p>例如$(‘.lf-index’).css(“backgroundImage”)<br>ios和macOS下返回url(<a href="http://i0.letvimg.com/images/bg.jpg" target="_blank" rel="external">http://i0.letvimg.com/images/bg.jpg</a> )<br>其余如安卓和windows的chrome下返回 url(“<a href="http://i0.letvimg.com/images/bg.jpg" target="_blank" rel="external">http://i0.letvimg.com/images/bg.jpg</a>“)</p>
</blockquote>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*获取所有图片路径*/</div><div class="line">function imgUrlArr() &#123;</div><div class="line">    var imgList = [],</div><div class="line">        imgEle = $(&quot;.lantern-festival&quot;).find(&quot;img&quot;),</div><div class="line">        bgImgEle = $(&quot;.lantern-festival&quot;).find(&quot;.bgimg&quot;),</div><div class="line">        imgEleArr = [].slice.call(imgEle).concat([].slice.call(bgImgEle));</div><div class="line">   // imgEleArr = imgEle;</div><div class="line">    for(var i= 0,l=imgEleArr.length;i&lt;l; i++)&#123;</div><div class="line">        if($(imgEleArr[i]).attr(&quot;src&quot;)) &#123;</div><div class="line">            imgList.push($(imgEleArr[i]).attr(&quot;src&quot;).replace(&quot;http:&quot;,&quot;&quot;));</div><div class="line">        &#125;else if($(imgEleArr[i]).css(&quot;background&quot;)) &#123;</div><div class="line">            if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&quot;&apos;) != -1) &#123;//其余如安卓和windows chrome下返回 url(&quot;http://i0.letvimg.com/images/bg.jpg&quot;)</div><div class="line">                var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;)</div><div class="line">                a = a.substr(1,a.length-1);</div><div class="line">                a=a.substr(0,a.length-1)</div><div class="line">                imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));</div><div class="line">            &#125;else if($(imgEleArr[i]).css(&quot;backgroundImage&quot;).indexOf(&apos;url(&apos;) != -1) &#123;//  ios下返回url(http://i0.letvimg.com/images/bg.jpg)</div><div class="line">                var a = $(imgEleArr[i]).css(&quot;backgroundImage&quot;).replace(&apos;url(&apos;,&apos;&apos;).replace(&apos;)&apos;,&apos;&apos;)</div><div class="line">                imgList.push(a.replace(&quot;https:&quot;,&quot;&quot;).replace(&quot;http:&quot;,&quot;&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> return imgList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> jquery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new image ().onload的问题]]></title>
      <url>/2016/10/29/newimage/</url>
      <content type="html"><![CDATA[<h4 id="loading-时用到的new-image-onload方法"><a href="#loading-时用到的new-image-onload方法" class="headerlink" title="loading 时用到的new image ().onload方法"></a>loading 时用到的new image ().onload方法</h4><p>new Image（）.onload方法有兼容性问题，图片有缓存后不同的浏览器会有不同的反应，有的会触发onload，有的则不会，具体可以上网查看。还有， src属性需要写在onload事件后面。如下</p>
<pre><code>var image=new Image();
imgae.onload = funtion;
imgae.src = &apos;url&apos;
</code></pre><p>因为js内部是按顺序逐行执行的，可以认为是同步的给imgae赋值src时，去加载图片这个过程是异步的，这个异步过程完成后，如果有onload，则执行onload<br>如果先赋值src，那么这个异步过程可能在你赋值onload之前就完成了（比如图片缓存，或者是js由于某些原因被阻塞了），那么onload就不会执行反之，js同步执行确定onload赋值完成后才会赋值src,可以保证这个异步过程在onload赋值完成后才开始进行，也就保证了onload一定会被执行到</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[new Date()的兼容问题]]></title>
      <url>/2016/10/02/newdate/</url>
      <content type="html"><![CDATA[<h4 id="new-Date-“2016-12-08-12-58-58”-有兼容性问题"><a href="#new-Date-“2016-12-08-12-58-58”-有兼容性问题" class="headerlink" title="new Date(“2016-12-08  12:58:58”)有兼容性问题"></a>new Date(“2016-12-08  12:58:58”)有兼容性问题</h4><blockquote>
<p>ios下解析new Date(“2016-12-08  12:58:58”)有兼容性问题，将-替换成/</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fixed定位的弹窗与虚拟键盘的兼容性问题]]></title>
      <url>/2016/09/08/fixed_dialog/</url>
      <content type="html"><![CDATA[<h4 id="ios下uc浏览器中fixed定位的弹窗与虚拟键盘的兼容性问题"><a href="#ios下uc浏览器中fixed定位的弹窗与虚拟键盘的兼容性问题" class="headerlink" title="ios下uc浏览器中fixed定位的弹窗与虚拟键盘的兼容性问题"></a>ios下uc浏览器中fixed定位的弹窗与虚拟键盘的兼容性问题</h4><p>弹窗中有input输入框，当输入框获得焦点时，虚拟键盘弹出。如果键盘遮挡住了弹窗，那么被遮挡的部分将会被键盘截去。所以移动端的有输入框的弹窗全部不能用fixed定位，用absolute定位代替。</p>
]]></content>
      
        <categories>
            
            <category> 兼容性 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IE8 placeholder 不兼容的问题]]></title>
      <url>/2016/08/28/placeholder/</url>
      <content type="html"><![CDATA[<h3 id="解决IE8-placeholder-不兼容的问题"><a href="#解决IE8-placeholder-不兼容的问题" class="headerlink" title="解决IE8 placeholder 不兼容的问题"></a>解决IE8 placeholder 不兼容的问题</h3><pre><code>jQuery(&apos;[placeholder]&apos;).focus(function() {
     var input = jQuery(this);
      if (input.val() == input.attr(&apos;placeholder&apos;)) {
        input.val(&apos;&apos;);
        input.removeClass(&apos;placeholder&apos;);
      }
    }).blur(function() {
      var input = jQuery(this);
      if (input.val() == &apos;&apos; || input.val() == input.attr(&apos;placeholder&apos;)) {
        input.addClass(&apos;placeholder&apos;);
        input.val(input.attr(&apos;placeholder&apos;));
      }
    }).blur().parents(&apos;form&apos;).submit(function() {
      jQuery(this).find(&apos;[placeholder]&apos;).each(function() {
        var input = jQuery(this);
        if (input.val() == input.attr(&apos;placeholder&apos;)) {
          input.val(&apos;&apos;);
        }
      })
    });
</code></pre>]]></content>
      
        <categories>
            
            <category> 兼容性 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IE8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rgba和opacity的区别]]></title>
      <url>/2016/07/22/rgba_opacity/</url>
      <content type="html"><![CDATA[<p>rgba和opacity均是css3方法，不支持ie8及其以下浏览器，网上有解决办法.</p>
<blockquote>
<p>透明度表示透明的程度，在开发过程中我们常说的透明度其实是不透明度，如果用0和1表示透明度的区间，一个完全透明的玻璃杯它的透明度（透明的程度）为1，不透明度为0，也就是alpha和opacity的值为0。<br>opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。可以理解为opacity有遗传性，rgba没有。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[button标签的默认类型]]></title>
      <url>/2016/06/28/button/</url>
      <content type="html"><![CDATA[<p>表单中有<button>一旦点击就会自动提交表单，因为</button><button>标签的type属性默认为“submit”。要给</button><button>加上type=“button”属性才可以</button></p>
]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery 的 attr 与 prop 的区别]]></title>
      <url>/2016/06/25/attr_prop/</url>
      <content type="html"><![CDATA[<p>先提出问题：对于 checked 这类值是 true/false 的属性，用 jQuery 的 attr 或 prop 方法进行 读取或设置值是有区别的。</p>
<p>在看 jQuery 文档前，我们先看看 attribute 与 property 是什么：</p>
<p>###先搞懂 attribute 与 property</p>
<p>当编写 HTML 源码时，你能在 HTML 元素里定义 attributes。然后，一旦浏览器解析你的代码，该 HTML 元素相应的 DOM 节点就会被创建。该节点是一个对象，因此它就拥有 properties。<br>因此，我们知道：attributes 是 HTML 元素（标签）的属性，而 properties 是 DOM 对象的属性。</p>
<p>例如，下面这个 HTML 元素：</p>
<pre><code>&lt;input type=&quot;text&quot; value=&quot;Name:&quot;&gt;
</code></pre><p>拥有两个 attributes。</p>
<p>一旦浏览器解析该代码，HTMLInputElement 对象就会被创建，并且该对象会拥有很多 peoperties，如：accept、accessKey、align、alt、attributes、autofocus、baseURI、checked、childElementCount、ChildNodes、children、classList、className、clientHeight 等等。</p>
<p>对于某个 DOM 节点对象，properties 是该对象的所有属性，而 attributes 是该对象对应元素(标签)的属性。</p>
<p>当一个 DOM 节点为某个 HTML 元素所创建时，其大多数 properties 与对应 attributes 拥有相同或相近的名字，但这并不是一对一的关系。例如，下面这个 HTML 元素：</p>
<pre><code>&lt;input id=&quot;the-input&quot; type=&quot;text&quot; value=&quot;Name:&quot;&gt;
</code></pre><p>其对应 DOM 节点会拥有如下properties： id、type 和 value：</p>
<ul>
<li><code>id</code> property是 <code>id</code> attribute 的映射：获取该 property 即等于读取其对应的 attribute 值，而设置该 property 即为 attribute 赋值。<code>id</code> 是一个纯粹的映射 property，它不会修改或限制其值。</li>
<li><code>type</code> property 是 <code>type</code> attribute 的映射：获取该 property 即等于读取其对应的 attribute 值，而设置该 property 即为 attribute 赋值。但 <code>type</code> 并不是一个纯粹的映射 property，因为它的值被限制在已知值（即 input 的合法类型，如：text、password）。如果你有 <code>&lt;input type=&quot;foo&quot;&gt;</code>，然后 <code>theInput.getAttribute(&quot;type&quot;)</code> 会返回 <code>&quot;foo&quot;</code>，而 <code>theInput.type</code> 会返回 <code>&quot;text&quot;</code>。</li>
<li><p>相比之下，<code>value</code> property 并不会映射 <code>value</code> attribute。取而代之的是 input 的当前值。当用户手动更改输入框的值，<code>value</code> property 会反映该改变。所以，如果用户在 input 输入 <code>John</code>，然后：</p>
<p> theInput.value // 返回 “John”<br>然而：<br> theInput.getAttribute(‘value’) // 返回 “Name:”</p>
</li>
</ul>
<p><code>value</code> property 反映了 input 的<strong>当前</strong>文本内容，而 <code>value</code> attribute 则是在 HTML 源码 value 属性所指定的<strong>初始</strong>文本内容。</p>
<p>因此，如果你想知道文本框的当前值，则读取 property。而如果你想知道文本框的初始值，则读取 attribute。或者你也可以利用 defaultValue property，它是 value attribute 的纯粹映射。</p>
<pre><code>theInput.value                 // returns &quot;John&quot;
theInput.getAttribute(&apos;value&apos;) // returns &quot;Name:&quot;
theInput.defaultValue          // returns &quot;Name:&quot;
</code></pre><p>有几个 properties 是直接反映它们 attribute（rel、id），而有一些则用稍微不同的名字进行直接映射（<code>htmlFor</code> 映射 <code>for</code> attribute，<code>className</code> 映射 <code>class</code> attribute）。很多 property 所映射的 attribute 是带有限制/变动的（src、href、disabled、multiple）。该 <a href="https://www.w3.org/TR/html5/infrastructure.html#reflect" target="_blank" rel="external">规范</a> 涵盖了各种各样的映射。</p>
<p>###再看看 attr() 与 prop() 的区别</p>
<p>上述能让我们理清了 attribute 与 property 之间的区别，下面根据 <a href="http://api.jquery.com/prop/" target="_blank" rel="external">jQuery 文档</a> 对 attr() 与 prop() 方法进行比较：</p>
<p>自 jQuery 1.6 版本起，<code>attr()</code> 方法对于未设置的 attributes （即标签中没写该 attributes）都会返回 <code>undefined</code>。对于检索和改变 DOM 的 properties，如表单元素的 checked、selected 或 disabled 状态，应使用 <code>.prop()</code> 方法。</p>
<p>Attributes vs. Properties</p>
<p>attributes 与 properties 之间的差异在特定情况下会变得尤为重要。在 jQuery 1.6 前，<code>.attr()</code> 方法在检索一些 attributes 时，有时会把 property 考虑进去，这会导致不一致的行为。在 jQuery 1.6 版本之后，<code>.prop()</code> 方法提供了一种明确检索 property 值的方式，而 <code>.attr</code> 只会检索 attributes。</p>
<p>例如，selectedIndex、tagName、nodeName、nodeType、ownerDocument、defaultChecked 和 defaultSelected 能被 <code>.prop()</code> 检索与设置。在 jQuery 1.6 之前，这些 properties 都是通过 <code>.attr()</code> 检索的，但检索这些属性并不应属于 attr 方法职责内 。这些属性并没有对应的 attributes，只有 properties 本身。</p>
<p>对于值为布尔值的 attributes ，考虑到一个 DOM 元素是通过 HTML 标签 <code>&lt;input type=&quot;checkbox&quot; checked=&quot;checked /&gt;</code> 定义的，并且假定它在 JavaScript 的变量名为 <code>elem</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">读取属性</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">elem.checked</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">会随着 checkbox 状态作出相应改变</td>
</tr>
<tr>
<td style="text-align:left">$(elem).prop(“checked”)</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">会随着 checkbox 状态作出相应改变</td>
</tr>
<tr>
<td style="text-align:left">elem.getAttribute(“checked”)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left">checkbox 的初始状态；并且不会随着 checkbox 的状态而改变。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left">checkbox 的初始状态；并且不会随着 checkbox 的状态而改变。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6.1+)</td>
<td style="text-align:left">“checked” (String)</td>
<td style="text-align:left"><del>会随着 checkbox 状态而作出相应改变</del>（与jQuery文档描述不一样，我用jQuery 1.12.1 测试，都是返回 “checked”，并不会随着checkbox的改变而改变）。</td>
</tr>
<tr>
<td style="text-align:left">$(elem).attr(“checked”) (1.6之前版本)</td>
<td style="text-align:left">true (Boolean)</td>
<td style="text-align:left">true (Boolean) 会随着 checkbox 状态作出相应改变。</td>
</tr>
</tbody>
</table>
<p>根据 W3C forms（表单） 规范，<code>checked</code> 是一个值为 boolean 的 attribute，这意味着当该 attribute 存在（无论值是什么），其对应的 property 都是 true。例如，该 attribute 没赋值或设为空字符串，甚至设为 <code>&quot;false&quot;</code>。这同样适用于所有值为 boolean 的 attributes。</p>
<p>然而，对于 <code>checked</code> attribute 最重要的概念是记住它并不是对应 <code>checked</code> property。该 attribute 实际上是对应 <code>defaultChecked</code> property，并仅在初次设置 checkbox 值时使用。<code>checked</code> attribute 的值并不会随着 checkbox 的状态而作出相应改变，而 <code>checked</code> property 会。因此，为了兼容不同浏览器，当判断一个 checkbox 是否被选择时应该使用 <code>property</code>：</p>
<pre><code>if (elem.checked)
if ($(elem).prop(&quot;checked&quot;))
if ($(elem).is(&quot;:checked&quot;))
</code></pre><p>这同样适用于其它动态 attributes，如 selected 和 value。</p>
<p>其他说明：<br>在 IE9 之前的版本，如果使用 <code>.prop()</code> 为 DOM 元素的 property 设置的值不是一个简单的原始值（number、string 或 boolean），且该 property 在 DOM 元素从 document 移除前未被移除（使用 .removeProp()），则会导致内存泄漏。为 DOM 对象设置值的安全做法（避免内存泄漏）是使用  <code>.data()</code>。</p>
<p>参考（翻译）：<br>jQuery API Documentation：<a href="http://api.jquery.com/prop/" target="_blank" rel="external">http://api.jquery.com/prop/</a><br>Properties and Attributrs in HTML：<a href="http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html" target="_blank" rel="external">http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html</a></p>
<hr>
<p>Github 地址: <a href="https://github.com/JChehe/blog/blob/master/posts/jQuery%20%E7%9A%84%20attr%20%E4%B8%8E%20prop%20%E7%9A%84%E5%8C%BA%E5%88%AB.md" target="_blank" rel="external">jQuery 的 attr 与 prop 的区别</a></p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery中on和bind的区别]]></title>
      <url>/2016/06/23/on_bind/</url>
      <content type="html"><![CDATA[<blockquote>
<p>bind()函数是jQuery 1.7之前或更早版本采用的一个用来绑定事件处理程序的函数；on()函数是jQuery 1.7版本提供的首选的用来绑定事件处理程序的函数；从1.7版本的介绍以及参数描述来看，其实这两个函数基本上用法一致，但可能在早期的版本中，bind()函数一次只能为标签对象绑定一个事件的处理程序，而on()函数则可以一次为多个不同的事件绑定处理程序。</p>
</blockquote>
<p>delegate()采用事件委托的概念，这样可以不用再为一个大盒子里面的所有子盒子绑定事件， 当在大盒子内任意元素上点击时，事件会一层层从event target向上冒泡，直至到达你为其绑定事件的元素。冒泡的过程中，如果事件的currentTarget与选择器匹配时，就会执行代码。 也可以为动态添加进大盒子的子元素绑定事件。</p>
<p>on()方法综合了bind()和delegate()方法。尽量使用on()方法。</p>
]]></content>
      
        <categories>
            
            <category> jquery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[$(this).index()]]></title>
      <url>/2016/06/23/$_index/</url>
      <content type="html"><![CDATA[<p>$(this).index()获取的是该元素在<strong>兄弟元素</strong>中的索引    </p>
]]></content>
      
        <categories>
            
            <category> jquery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《少年维特之烦恼》（节选）]]></title>
      <url>/2014/04/24/weite/</url>
      <content type="html"><![CDATA[<p>#####<br>在维特心中，深深种着烦恼和忧郁，这个根扎得越来越深，并且虬根交错，把他的身和心全部牢牢占据，彻底毁坏了维特精神的和谐宁静。内心的狂躁和激愤把他天赋中全部的本来力量摧残殆尽，后果相当坏，让他筋疲力竭。他曾徒然苦苦挣扎，只为摆脱这种恶劣的状态，比起以前和种种弊端斗争来，他更加胆怯、惶恐不安，这些都让维特所剩无几的精神力量、活泼天性、聪敏机智都消耗殆尽。从此，终日萦绕他的是悲伤和失望，他变得越来越悲惨，越来越蛮不讲理，于是，他更加不幸了。</p>
]]></content>
      
        <categories>
            
            <category> 自说自话 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
